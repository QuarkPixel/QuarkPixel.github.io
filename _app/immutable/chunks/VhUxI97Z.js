import"./CWj6FrbW.js";import"./BaCqQUOQ.js";import{t as B,s as a,f as x,e as s,b as j,r as n,n as $}from"./DoEgfuwQ.js";import{h as p}from"./CKrLjoKW.js";import{l as S,s as E}from"./eyEfEEVO.js";import{B as T}from"./GVXTG7aE.js";import{I as k}from"./BAKXVhBz.js";const r={title:"网页排版碎碎念",description:"记录这个博客网站在排版技术上的一些探索和实践",date:"2025-09-16T02:34:40.000Z",author:"Xuancong Meng",tags:["Web","Typography","Technique"],layout:"blog"},{title:O,description:Q,date:W,author:D,tags:F,layout:G}=r;var X=B('<p>作为一个以文字内容为主的博客网站，排版质量直接影响着读者的阅读体验。在<a href="./250701-remake-typography">重做网页布局排版</a>转向 Tailwind Typography 之后，我对网站的排版系统进行了进一步的优化，主要集中在字体加载和智能断行两个方面。这篇文章就来聊聊这些排版技术的具体实现。</p> <h2 id="字体分包"><a class="anchor-link not-prose" href="#字体分包">字体分包</a></h2> <h3 id="中文字体的加载难题"><a class="anchor-link not-prose" href="#中文字体的加载难题">中文字体的加载难题</a></h3> <p>中文字体文件往往体积庞大，动辄几十 MB。像霞鹜文楷这样的优质字体，单个字重就有 <a href="https://github.com/lxgw/LxgwWenKai/releases/" rel="nofollow">20+ MB</a>，对网页首屏加载是沉重负担。</p> <h3 id="字体分包解君愁"><a class="anchor-link not-prose" href="#字体分包解君愁">字体分包解君愁</a></h3> <p>和好友 <a href="https://studiountagged.top/" rel="nofollow">Steven Liu</a> 交流时，我了解到<a href="https://chinese-font.netlify.app" rel="nofollow">中文网字计划</a>提供的<a href="https://chinese-font.netlify.app/zh-cn/online-split/" rel="nofollow">字体分包器</a>。其核心思路是：将完整的字体文件拆分成若干 <code>woff2</code> 分包，浏览器只在渲染页面所需文字时才加载对应的片段，而不必下载整个字体。这样大幅减少了首次加载体积，而大多数不常用的生僻字则不会被请求。</p> <h3 id="渐进式加载的体验"><a class="anchor-link not-prose" href="#渐进式加载的体验">渐进式加载的体验</a></h3> <p>使用字体分包后，网站呈现出独特的「字体逐步加载」效果。有《黑客帝国》的即视感。</p> <p><!></p> <h2 id="智能断行"><a class="anchor-link not-prose" href="#智能断行">智能断行</a></h2> <h3 id="浏览器自带的断行"><a class="anchor-link not-prose" href="#浏览器自带的断行">浏览器自带的断行</a></h3> <p>CSS 中有一个非常有用的属性 <code>word-break: auto-phrase</code>，它能够按照语言的语义单位进行断行，避免在奇怪的位置换行。</p> <p><!></p> <p>然而现实很骨感，这个属性目前<a href="https://developer.chrome.com/blog/css-i18n-features?hl=zh-cn#japanese_phrase_line_breaking_word-break_auto-phrase" rel="nofollow">只支持日文</a>，对中文的支持还在开发中。对于一个中文博客网站来说，这显然无法满足需求。</p> <h3 id="budoux-真是太香了"><a class="anchor-link not-prose" href="#budoux-真是太香了">BudouX 真是太香了</a></h3> <p>为了解决这个问题，我引入了 Google 开源的 <a href="https://github.com/google/budoux" rel="nofollow">BudouX</a> 工具。BudouX 是 Budou 的后继产品，是一个机器学习驱动的断行组织工具。</p> <h4 id="工作原理"><a class="anchor-link not-prose" href="#工作原理">工作原理</a></h4> <p>BudouX 的核心思想是将文本按语义切分为数组，例如：</p> <pre class="language-javascript"><!></pre> <p>配合特定的 CSS 属性，这样的文本可以优先在数组元素之间进行断行，而不是在字符中间强制换行。以下是用Svelte实现的自定义展示组件：</p> <pre class="language-svelte"><!></pre> <h4 id="实现效果"><a class="anchor-link not-prose" href="#实现效果">实现效果</a></h4> <p>你可以尝试缩放本网页来观察标题部分的换行效果。相比于浏览器的默认断行逻辑，BudouX 优化后的断行更符合中文的阅读习惯，避免了语义单位被不合理拆分的问题。</p> <h2 id="其他排版优化"><a class="anchor-link not-prose" href="#其他排版优化">其他排版优化</a></h2> <p>在 <a href="https://github.com/QuarkPixel/QuarkPixel.github.io/blob/master/src/lib/styles/article.scss" rel="nofollow"><code>article.scss</code></a> 中，我还应用了一些现代 CSS 排版特性：</p> <h3 id="文本对齐与标点悬挂"><a class="anchor-link not-prose" href="#文本对齐与标点悬挂">文本对齐与标点悬挂</a></h3> <pre class="language-scss"><!></pre> <p><code>hanging-punctuation</code> 属性让标点符号可以”悬挂”在文本行的边界之外，这是中文排版中的传统做法，能让文本边界看起来更加整齐。但可惜的是目前大部分浏览器都还不支持 :(</p> <h3 id="链接样式优化"><a class="anchor-link not-prose" href="#链接样式优化">链接样式优化</a></h3> <pre class="language-scss"><!></pre> <p>链接使用了自定义的波浪线装饰效果，既保持了视觉识别度，又不会过于突兀地破坏阅读节奏。具体灵感来源等信息可查看周刊 <a href="/logs/0xB59#%E7%BD%91%E7%AB%99%E7%9A%84%E5%85%B6%E4%BB%96%E5%8F%98%E5%8A%A8">0xB59</a>。</p> <h2 id="碎碎念"><a class="anchor-link not-prose" href="#碎碎念">碎碎念</a></h2> <p>我是一个很爱扣细节的人，舒适的排版令我愉快。曾经有人说我适合去做文字排版相关的工作，我自己也是这么想的。在此特感谢 Eric Liu 与 钱争予 老师，他们的播客<a href="https://www.thetype.com/typechat/" rel="nofollow">《字谈字畅》</a>在排版方面的科普给予了我很多帮助，如果没有这样播客形式的科普我可能从来都不会对字体排印有这么深刻的认识😂。</p>',1);function z(h,g){const d=S(g,["children","$$slots","$$events","$$legacy"]);T(h,E(()=>d,r,{children:(f,A)=>{var u=X(),t=a(x(u),16),m=s(t);k(m,{src:"/img/250916-0.webp",alt:"字体渐进式加载效果演示"}),n(t);var o=a(t,8),v=s(o);k(v,{src:"https://developer.chrome.com/blog/css-i18n-features/image/word-break-auto-phrase.png",alt:"word-break: auto-phrase 会在自然词组边界处换行"}),n(o);var e=a(o,12),w=s(e);p(w,()=>`<code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'这是段需要优化断行的文本'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ['这', '是', '段', '需要', '优化', '断行', '的', '文本']</span></code>`),n(e);var c=a(e,4),_=s(c);p(_,()=>`<code class="language-svelte"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
	<span class="token keyword">const</span> <span class="token punctuation">&#123;</span> text<span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token operator">:</span> className <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token operator">...</span>rest <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">$props</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>

<span class="token each"><span class="token punctuation">&#123;</span><span class="token keyword">#each</span> <span class="token language-javascript">text </span><span class="token keyword">as</span> <span class="token language-javascript">word<span class="token punctuation">,</span> i </span><span class="token language-javascript"><span class="token punctuation">(</span>i<span class="token punctuation">)</span></span><span class="token punctuation">&#125;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>word-break: keep-all; overflow-wrap: anywhere;<span class="token punctuation">"</span></span> <span class="token attr-name">class=</span><span class="token language-javascript"><span class="token punctuation">&#123;</span>className<span class="token punctuation">&#125;</span></span> <span class="token language-javascript"><span class="token punctuation">&#123;</span><span class="token operator">...</span>rest<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span>
		<span class="token language-javascript"><span class="token punctuation">&#123;</span>word<span class="token punctuation">&#125;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
<span class="token each"><span class="token punctuation">&#123;</span><span class="token keyword">/each</span><span class="token punctuation">&#125;</span></span></code>`),n(c);var l=a(c,12),y=s(l);p(y,()=>`<code class="language-scss"><span class="token selector">.prose </span><span class="token punctuation">&#123;</span>
	<span class="token property">text-align</span><span class="token punctuation">:</span> justify<span class="token punctuation">;</span> <span class="token comment">// 两端对齐</span>
	<span class="token property">quotes</span><span class="token punctuation">:</span> <span class="token string">'「'</span> <span class="token string">'」'</span> <span class="token string">'『'</span> <span class="token string">'』'</span><span class="token punctuation">;</span> <span class="token comment">// 中文引号样式</span>
	<span class="token property">hanging-punctuation</span><span class="token punctuation">:</span> first last<span class="token punctuation">;</span> <span class="token comment">// 标点悬挂</span>
<span class="token punctuation">&#125;</span></code>`),n(l);var i=a(l,6),b=s(i);p(b,()=>`<code class="language-scss"><span class="token punctuation">:</span><span class="token function">where</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token function">where</span><span class="token punctuation">(</span>[class~=<span class="token string">'not-prose'</span>]<span class="token punctuation">,</span> [class~=<span class="token string">'not-prose'</span>] *<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
	<span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--tw-prose-body<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">@include</span> wave.<span class="token function">auto-theme</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`),n(i),$(6),j(f,u)},$$slots:{default:!0}}))}const K=Object.freeze(Object.defineProperty({__proto__:null,default:z,metadata:r},Symbol.toStringTag,{value:"Module"}));export{K as _};
