{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hsuan's Space",
    "home_page_url": "https://quarkpixel.github.io",
    "feed_url": "https://quarkpixel.github.io/feed/feed.json",
    "description": "Hsuan's personal blog about tech, life, and thoughts",
    "icon": "https://quarkpixel.github.io/favicon/dark.svg",
    "author": {
        "name": "Xuancong Meng",
        "url": "https://quarkpixel.github.io"
    },
    "items": [
        {
            "id": "https://quarkpixel.github.io/p/250916-typography-thoughts",
            "content_html": "<p>作为一个以文字内容为主的博客网站，排版质量直接影响着读者的阅读体验。在<a href=\"./250701-remake-typography\">重做网页布局排版</a>转向 Tailwind Typography 之后，我对网站的排版系统进行了进一步的优化，主要集中在字体加载和智能断行两个方面。这篇文章就来聊聊这些排版技术的具体实现。</p>\n<h2>字体分包</h2>\n<h3>中文字体的加载难题</h3>\n<p>中文字体文件往往体积庞大，动辄几十 MB。像霞鹜文楷这样的优质字体，单个字重就有 <a href=\"https://github.com/lxgw/LxgwWenKai/releases/\">20+ MB</a>，对网页首屏加载是沉重负担。</p>\n<h3>字体分包解君愁</h3>\n<p>和好友 <a href=\"https://studiountagged.top/\">Steven Liu</a> 交流时，我了解到<a href=\"https://chinese-font.netlify.app\">中文网字计划</a>提供的<a href=\"https://chinese-font.netlify.app/zh-cn/online-split/\">字体分包器</a>。其核心思路是：将完整的字体文件拆分成若干 <code>woff2</code> 分包，浏览器只在渲染页面所需文字时才加载对应的片段，而不必下载整个字体。这样大幅减少了首次加载体积，而大多数不常用的生僻字则不会被请求。</p>\n<h3>渐进式加载的体验</h3>\n<p>使用字体分包后，网站呈现出独特的「字体逐步加载」效果。有《黑客帝国》的即视感。</p>\n<p><img src=\"/img/250916-0.webp\" alt=\"字体渐进式加载效果演示\"></p>\n<h2>智能断行</h2>\n<h3>浏览器自带的断行</h3>\n<p>CSS 中有一个非常有用的属性 <code>word-break: auto-phrase</code>，它能够按照语言的语义单位进行断行，避免在奇怪的位置换行。</p>\n<p><img src=\"https://developer.chrome.com/blog/css-i18n-features/image/word-break-auto-phrase.png\" alt=\"word-break: auto-phrase 会在自然词组边界处换行\"></p>\n<p>然而现实很骨感，这个属性目前<a href=\"https://developer.chrome.com/blog/css-i18n-features?hl=zh-cn#japanese_phrase_line_breaking_word-break_auto-phrase\">只支持日文</a>，对中文的支持还在开发中。对于一个中文博客网站来说，这显然无法满足需求。</p>\n<h3>BudouX 真是太香了</h3>\n<p>为了解决这个问题，我引入了 Google 开源的 <a href=\"https://github.com/google/budoux\">BudouX</a> 工具。BudouX 是 Budou 的后继产品，是一个机器学习驱动的断行组织工具。</p>\n<h4>工作原理</h4>\n<p>BudouX 的核心思想是将文本按语义切分为数组，例如：</p>\n<pre><code class=\"language-javascript\">console.log(parse(&#39;这是段需要优化断行的文本&#39;));\n// [&#39;这&#39;, &#39;是&#39;, &#39;段&#39;, &#39;需要&#39;, &#39;优化&#39;, &#39;断行&#39;, &#39;的&#39;, &#39;文本&#39;]\n</code></pre>\n<p>配合特定的 CSS 属性，这样的文本可以优先在数组元素之间进行断行，而不是在字符中间强制换行。以下是用Svelte实现的自定义展示组件：</p>\n<pre><code class=\"language-svelte\">&lt;script&gt;\n\tconst { text, class: className = &#39;&#39;, ...rest } = $props();\n&lt;/script&gt;\n\n{#each text as word, i (i)}\n\t&lt;span style=&quot;word-break: keep-all; overflow-wrap: anywhere;&quot; class={className} {...rest}&gt;\n\t\t{word}\n\t&lt;/span&gt;\n{/each}\n</code></pre>\n<h4>实现效果</h4>\n<p>你可以尝试缩放本网页来观察标题部分的换行效果。相比于浏览器的默认断行逻辑，BudouX 优化后的断行更符合中文的阅读习惯，避免了语义单位被不合理拆分的问题。</p>\n<h2>其他排版优化</h2>\n<p>在 <a href=\"https://github.com/QuarkPixel/QuarkPixel.github.io/blob/master/src/lib/styles/article.scss\"><code>article.scss</code></a> 中，我还应用了一些现代 CSS 排版特性：</p>\n<h3>文本对齐与标点悬挂</h3>\n<pre><code class=\"language-scss\">.prose {\n\ttext-align: justify; // 两端对齐\n\tquotes: &#39;「&#39; &#39;」&#39; &#39;『&#39; &#39;』&#39;; // 中文引号样式\n\thanging-punctuation: first last; // 标点悬挂\n}\n</code></pre>\n<p><code>hanging-punctuation</code> 属性让标点符号可以&quot;悬挂&quot;在文本行的边界之外，这是中文排版中的传统做法，能让文本边界看起来更加整齐。但可惜的是目前大部分浏览器都还不支持 :(</p>\n<h3>链接样式优化</h3>\n<pre><code class=\"language-scss\">:where(a):not(:where([class~=&#39;not-prose&#39;], [class~=&#39;not-prose&#39;] *)) {\n\ttext-decoration: none;\n\tcolor: var(--tw-prose-body);\n\t@include wave.auto-theme();\n}\n</code></pre>\n<p>链接使用了自定义的波浪线装饰效果，既保持了视觉识别度，又不会过于突兀地破坏阅读节奏。具体灵感来源等信息可查看周刊 <a href=\"/logs/0xB59#%E7%BD%91%E7%AB%99%E7%9A%84%E5%85%B6%E4%BB%96%E5%8F%98%E5%8A%A8\">0xB59</a>。</p>\n<h2>碎碎念</h2>\n<p>我是一个很爱扣细节的人，舒适的排版令我愉快。曾经有人说我适合去做文字排版相关的工作，我自己也是这么想的。在此特感谢 Eric Liu 与 钱争予 老师，他们的播客<a href=\"https://www.thetype.com/typechat/\">《字谈字畅》</a>在排版方面的科普给予了我很多帮助，如果没有这样播客形式的科普我可能从来都不会对字体排印有这么深刻的认识😂。</p>\n",
            "url": "https://quarkpixel.github.io/p/250916-typography-thoughts",
            "title": "网页排版碎碎念",
            "summary": "记录这个博客网站在排版技术上的一些探索和实践",
            "date_modified": "2025-09-16T02:34:40.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "['Web'",
                "'Typography'",
                "'Technique']"
            ]
        },
        {
            "id": "https://quarkpixel.github.io/p/250915-shake",
            "content_html": "<p>刷到了<a href=\"https://v.douyin.com/onmLtrYkhNA/\">以前和前女友去过的一家小书店</a>。</p>\n<p>那家书店很小，很美，很低调。以至于我已近乎将其忘却。</p>\n<p>但我刷到它时，我的心<strong>颤动</strong>。</p>\n<p>我无法再用更精准的词去形容自己的状态，这个感受太微妙：美好的回忆、痛苦的回忆以及当晚我和她在那散步的当下。<strong>像突然打开的淋浴一样冲刷着身体。</strong></p>\n<p>当时的我在想些什么呢？我已经有些记不清了。</p>\n<p><img src=\"/img/250915-1.jpeg\" alt=\"\"></p>\n<p><img src=\"/img/250915-2.jpeg\" alt=\"\"></p>\n<p><img src=\"/img/250915-0.jpeg\" alt=\"\">\n<em>图片下方的一楼即为所述书店，当时的随手一拍。</em></p>\n",
            "url": "https://quarkpixel.github.io/p/250915-shake",
            "title": "颤动",
            "summary": "短篇文，想试着记录下自己的感受",
            "date_modified": "2025-09-15T04:02:45.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": []
        },
        {
            "id": "https://quarkpixel.github.io/logs/0xB5A",
            "content_html": "<p>最近在看 CSAPP 中关于 Dynamic Memory Allocation 的内容，并且准备开始写 Malloc Lab 。听起来好像挺充实的，但实际上不知从何时起我的学习效率变得极低，一直不见什么进展。可能总是和身边发生的各种事以及对该任务的低优先级有关吧。</p>\n<h2>论创作预期</h2>\n<p>说来神奇，在我主动地<a href=\"/logs/0xB59#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99-logs\">降低了自己的创作预期</a>后，我反而更能将生活中的一些见闻转化成所写，从而达成了更高的创作频率。我认为这与自己不再在意一些所谓的「个人包袱」后更加轻松有关：不用在意自己写的是什么，流水账也好发牢骚也好，都是写给自己看的。这样的想法帮助我很多。</p>\n<p>提到创作预期，我还想到了自己曾经听过的一集播客：<a href=\"https://www.xiaoyuzhoufm.com/episode/684435c36dbe9284e741eb6e\">《这世上的偶然》：看得见，就是邂逅的开始吧</a> 。播客中同样讨论的是与「创作预期」相关的话题，但讨论的侧重点不一样：<strong>不要试着去规划好一切，因为你根本没法预料到创作的过程中会有什么新的灵感迸发。当你计划好一切时，反而会限制自己的创作力。</strong></p>\n<p>有趣的是，尽管关注点不一样、目的也不一样的前提下，其外化的表现形式却与我目前所践行的几乎一致。这让我联想到乔布斯刻意将房间弄得凌乱，从中获得灵感，将原本一点也不相关的事物联系在一起的选择。这貌似是一个更大的话题了，今天先点到为止～</p>\n<p><del>（反正我是忍受不了房间凌乱，会有强烈的失控感，令人厌烦 👎）</del></p>\n<h2>银翼杀手 2049</h2>\n<p>在晚饭时刷马克骐的《银翼杀手2049》拉片，感触很深以至于写了篇<a href=\"/p/250909-sex-between-k-joy-prostitute\">相关笔记</a>。我打算找个时间重新再看一遍这部电影，貌似有挺多地方之前都没有看懂。</p>\n<h2>论崇拜</h2>\n<p>在完成了那篇拉片笔记后，分享给了与自己玩的很好的一个初中同学。他是个怪人，平时与他讨论深度问题往往令人难以接受， 甚至自讽「有恋词癖」和「歇斯底里」。分享完没过多久，没有关于那篇文章内容的讨论，而是一句「傻逼齐泽克」。他一向如此直率，也特有魅力。</p>\n<p>令我感兴趣的是我们后续的讨论转变为了「不要信任何其他人」，言外之意就是不要崇拜别人（我还挺惊讶的，因为在我写到这里之前，我一直以为「崇拜」这个词是他先提出，我再进行反驳的。刚才在翻看聊天记录时才发现是我从他的话里提炼出了崇拜这个意味并且下意识的进行了转化）。我明确的和他表示我从来没有崇拜过齐泽克，我只是就事论事的讨论这件事本身。我最多只会欣赏某个人，并且更加频繁地去阅读ta的作品，企图获得更多的知识。</p>\n<p>后来细想了一下，貌似我从来没有崇拜过任何人；恰恰相反，我厌恶「崇拜」。这个词带有很强烈的「抛开理性判断、盲目的去追求某个人」的意味。说的言重些，「崇拜」是奴性的思想。</p>\n<h2>分手以后还能做朋友吗</h2>\n<p>在和朋友的聊天中又提到了这个话题。尽管本人在爱情中受的伤极深，但这个问题的答案在我心中仍是乌托邦般的「是」。</p>\n<p>我得出如此答案源自于自己对于另外一种社交能力的向往，即<strong>情景分隔</strong>。</p>\n<blockquote>\n<p>所谓情境分隔，可以用一个常见的场景来说明：\n创业中，白天在工作时因不同看法而吵的面红耳赤，甚至一度动手，气氛剑拔弩张；但一到下班，又能迅速把矛盾放下，好兄弟一样「走，吃饭去」，转而成为无话不谈的好兄弟。第二天回到工作场合，争吵依旧，但丝毫不影响其友情。</p>\n</blockquote>\n<p>「分手还做朋友」显然是这样情景分隔的升级版，甚至上述场景本身我都仍未习得。所以我不知道自己口中的实现起来到底有多难，或者到底能不能实现。</p>\n",
            "url": "https://quarkpixel.github.io/logs/0xB5A",
            "title": "Logs::0xB5A",
            "summary": "继上次 Log 糊了个副标题后，我仍不知道在这该写什么。",
            "date_modified": "2025-09-12T14:00:00.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": []
        },
        {
            "id": "https://quarkpixel.github.io/p/250909-sex-between-k-joy-prostitute",
            "content_html": "<p>看 <a href=\"https://space.bilibili.com/3546697279998233\">bilibili@马克骐</a> 的《银翼杀手2049》拉片，收获很多，是站内我见过最深刻的解读之一。其中对<a href=\"https://www.bilibili.com/video/BV1JxuVzLE9U/?t=631\">性爱片段</a>的分析令我很震撼，写些笔记。</p>\n<h2>与齐泽克「对坠入爱河的恐惧」</h2>\n<p>博主引用了齐泽克的一段访谈：</p>\n<center>\n    <iframe class=\"rounded\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rrxk2WzrE14?si=4XYjM4YaV947kUBB\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n</center>\n\n<p>这是博主搬来和电影场景并置的片段。但问题是：<strong>为什么要把齐泽克放进来？</strong></p>\n<p>毕竟两边的重点并不完全一样：齐泽克在批判<strong>现代人害怕真正去爱</strong>；拉片分析的却是<strong>爱本身的不可能性</strong>。听起来好像不太一样。</p>\n<h3>齐泽克在说什么</h3>\n<p>齐泽克是拉康派，他经常强调：幻想不是让我们远离真实，而是让我们能忍受真实。</p>\n<p>放到爱情里，就是：</p>\n<ul>\n<li>我们不是爱上了对方「本来的样子」；</li>\n<li>我们爱上的是在对方身上寄托的<strong>我们的幻想</strong>。</li>\n</ul>\n<p>所以在齐泽克看来，爱从来就是「间接」的，它必须通过幻想来运作。这也是齐泽克在《透过真实的裂缝》《暴力》等书中反复强调的立场。</p>\n<p>在这次访谈里，他更多是在讨论当代人为什么害怕坠入爱河：真正的爱是一种偶然的事件（<strong>fall</strong> in love），它无法计划，却能改变整个人生。现代人为了避免这种创伤，转而追求“去风险化”的爱——类似“无糖可乐”“无酒精啤酒”，一种可控的替代品。</p>\n<h3>与拉片的共振</h3>\n<p>这样就能理解博主的选择了。虽然齐泽克和拉片的落点不同，但他们碰到的共同点是：</p>\n<p><strong>爱从来不是直接的，它必须依赖幻想和虚拟的中介才能发生。</strong></p>\n<p>在电影里，这个逻辑被具象化：K 并没有真正「触碰」乔伊，而是借助妓女的身体作为中介。性爱在这里成了一场虚拟拼贴：既荒谬又动人，也揭示了爱只能通过虚拟结构间接实现。</p>\n<h2>真爱本身只存在于虚拟吗？</h2>\n<p>我认为博主还隐式地提出了一个问题：<strong>是不是所有的爱，其实都是“虚拟性爱”的变体？</strong></p>\n<p>博主在分析时已经点到：乔伊为了让自己的爱「有实感」，只能借助妓女的身体；而妓女在场时，她在意的也不是 K 本人，而是他在反抗组织中的价值。所有人都带着各自的幻想和目的进入性爱场景，于是性爱成了一种「双重虚拟」。荒谬，但又真实地触到了他们的需求。</p>\n<p>齐泽克的哲学恰好也解释了这一点：爱从来都需要幻想才能成立。我们从来不是爱上了一个人「真实的样子」，而是爱上了我们在对方身上寄托的投影。即使是真实的人与人之间的关系，也无法脱离这种「虚拟结构」。</p>\n<h3>「真爱」是否还可能存在</h3>\n<p>如果爱总是依赖幻想和虚拟，那么它到底还是真爱吗？</p>\n<p>齐泽克在访谈中提到了：真爱就是<strong>承认这种不可能性</strong>，却依然坚持与对方建立联系。</p>\n<ul>\n<li>爱并不是找到一个“刚好满足你所有幻想的人”。</li>\n<li>爱是接受对方的裂缝、缺失、不可满足。</li>\n</ul>\n<p>电影中的片段看似荒谬，但更是展现出了一种<strong>有力量的爱情</strong>。它的那种「不可能性」正是其魅力所在。</p>\n<p>这也解释了一个容易混淆的地方：齐泽克批判的对象，并不是像 K 和乔伊这样的人。相反，他们正是值得赞扬的——因为他们明知道不可能，依然尽全力去尝试接触所谓的真爱。齐泽克真正批判的，是那些甚至不去尝试、只追求安全替代品的人。</p>\n<h2>荒诞但动人</h2>\n<p>是不是所有的爱都是虚拟性爱的变体？我认为是的。但这并不是一种贬低，而是揭示。</p>\n<p><strong>我们明知不可及却又凭尽全力试着去拥有乌托邦式的爱情</strong>这件事本身，是我对这场戏的总结。这既是对《银翼杀手2049》性爱场景的注解，也是对齐泽克所说‘真正的爱’的一种影像化回应。</p>\n",
            "url": "https://quarkpixel.github.io/p/250909-sex-between-k-joy-prostitute",
            "title": "K、Joy、仿生人妓女与性爱",
            "summary": "《银翼杀手 2049》的拉片笔记",
            "date_modified": "2025-09-09T04:02:45.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": []
        },
        {
            "id": "https://quarkpixel.github.io/logs/0xB59",
            "content_html": "<p>这是本博客的第一篇周刊，周刊的内容主要就是发一些牢骚。</p>\n<h2>关于本周刊</h2>\n<h3>为什么写 &quot;Logs&quot;</h3>\n<p>本周与 <a href=\"https://www.guhub.cn/\">Eltrac</a> 写信交流，聊得很开心。交流中，老师建议我降低写作的心理门槛，并且保证持续的创作，即使是流水账也可以。故打算学习老师的 <a href=\"https://www.geedea.pro/posts/weekly/intro/\">稻草人周刊</a> ，尝试着去记一些生活中的小事。</p>\n<h3>设定上的一些趣事</h3>\n<p>关于该周刊，整体的设计我都是往 geeks 的方向上去靠拢的。以下是自己的一些想法～</p>\n<h4>名称</h4>\n<p>“Logs” 这个词本身就挺 geek 的，毕竟日志嘛。但后来才发现 “Blog” 一词竟然也是来自 “<a href=\"https://en.wikipedia.org/wiki/Blog\">Web log</a>”，觉得还蛮巧合的。但随着时间推移两个词所指代东西也不一样了，用 “Logs” 作为我的周刊名称我觉得也无伤大雅 😁。</p>\n<h4>编号</h4>\n<p>计算方式如下：</p>\n<p><img src=\"/img/logs/0xb59-0.gif\" alt=\"1970-01-01 to now to weeks to hex\">\n<em>所用的软件为 <a href=\"https://www.raycast.com/\">Raycast</a></em></p>\n<p>从 1970/01/01 开始计算，问就是<strong>极客精神</strong> 🤓</p>\n<h4>字体</h4>\n<p>使用了 <a href=\"https://fonts.adobe.com/fonts/calluna-sans\">Calluna Sans</a>，一款很有人文主义的无衬线体。最开始知道是我平时常听的播客 <a href=\"https://anyway.fm/\">Anyway.FM</a> 的官网默认西文字体。我比较喜欢它的\n<a href=\"https://fonts.google.com/knowledge/introducing_type/understanding_numerals\">oldstyle numerals</a> 设计，认为很适合在这里当作编号使用。</p>\n<h2>网站的其他变动</h2>\n<p>主要是<strong>更新了超链接样式</strong>，灵感同样是来源于 <a href=\"https://www.geedea.pro/posts/weekly/44/\">極客死亡計劃</a>（疯狂cue 🤪）：</p>\n<blockquote>\n<p>调整了超链接的样式，现在不再是蓝色，下划线的颜色也不那么显眼了，避免超链接起到不该有的强调作用（强调文本应该用粗体或者高亮样式）。</p>\n</blockquote>\n<p>其实我也早就注意到了这个问题。如果你留意的话，会记得原来的超链接样式就是正文样式的红色版本。但我一直没有修改、也不知道怎么改比较好，直到见到了帆迹老师的设计，有了灵感。<strong>在此特别感谢老师主动及无意中给予我的帮助</strong> 🌹。</p>\n<p><del>但是目前还是有一些显示 bug，需要再修😮‍💨</del></p>\n<h2>开学</h2>\n<p>9月1日了，开学了。每次开学我都和同学的感觉不太一样，有一种期待感。可能是自己平时生活相对还是比较孤僻吧，上学以后可以热闹一点。</p>\n<h2>群像的力量</h2>\n<p>我好像平时很能被所谓的群像的力量所打动。</p>\n<p><a href=\"https://xyzfm.link/s/G2Ip67\">分享播客《EP19: 黑人的歌白人唱》, 标记时点【15:26】</a></p>\n<blockquote>\n<p>1862 年年底美国南北战争进行时，联邦军和邦联军在田纳西的 Morphysboro 相遇。\n开战前一天，12 月 30 号，两边几千军人在战场上对峙。两边的军乐队就开始演奏，当然是两边演奏自己的爱国歌曲，就跟拉歌一样。北方奏一首 Yankee Doodle，南方就回应一首南方国歌 Dixie 这样的。\n最后呢，一边开始奏 Home Sweet Home，结果呢，另外一边也开始奏这首歌，变成了大家合唱一曲，收兵回营。没办法，当兵的最想家了，毕竟你都不知道自己还回得去回不去呢。这一唱就成了催泪弹。\n第二天，Stone&#39;s River 战役开打，三天里几千人战死，永远就回不了家了。</p>\n</blockquote>\n",
            "url": "https://quarkpixel.github.io/logs/0xB59",
            "title": "Logs::0xB59",
            "summary": "Intro",
            "date_modified": "2025-09-05T17:27:00.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "['Develop Diary']"
            ]
        },
        {
            "id": "https://quarkpixel.github.io/p/250810-perfectionism-also-kind-of-gardener-delusions",
            "content_html": "<p>读完 Eltrac 的文章《<a href=\"https://www.geedea.pro/posts/%E5%9B%AD%E4%B8%81%E5%A6%84%E6%83%B3%E7%97%87/\">园丁妄想症</a>》，<del>感觉被骂了</del> 引发了自己很多的反思。推荐去读原文。</p>\n<p>简单回顾一下文章的核心概念：「园丁妄想症」描述的是人们看到他人的完美成果后，立刻幻想自己也能拥有，却忽略了背后的过程、动机和现实条件等一整条链路。结果就是冲动行动，浪费资源，最终一事无成。</p>\n<p>但我发现，完美主义者的行为模式与此惊人相似——只不过他们不是在羡慕别人的花园，而是在追逐一个虚幻的「完美花园」。</p>\n<h2>相似的行为模式</h2>\n<p>读到原文中这段话时，我感到一种奇妙的熟悉感：</p>\n<blockquote>\n<p>之后，我急于调整个人主页的设计，几乎没有太多思考，把代码结构搞得乱七八糟，最后也没做出什么名堂。最好笑的是，两个小时过去了，我还在打磨那个「作品集」页面，而本来想做的 Now 页面和数字花园压根还没开始。</p>\n<p>就像开头故事里的小李，忙活了一下午也没种花，而是铺路，可最后路也没修好。</p>\n</blockquote>\n<p>这不就是完美主义的经典表现吗？</p>\n<p>完美主义者经常陷入这样的困境：为了追求一个理想化的结果，他们在细节上无休止地打磨，却忽略了真正重要的目标。他们害怕不完美，所以宁愿停留在 “准备阶段”，也不愿意面对现实的不完美。</p>\n<h2>完美主义的「内在妄想」</h2>\n<p>园丁妄想症的核心是对<strong>他人成果</strong>的幻想，而完美主义则是对<strong>理想自我</strong>的幻想。</p>\n<p>想象一下：你准备写一篇文章，脑海中浮现的是一篇逻辑完美、文笔优雅、观点深刻的作品。你甚至能想象读者读完后的赞叹，想象这篇文章为你带来的认可。这种 “完美图景” 一旦形成，现实中的任何不足都变得无法忍受。</p>\n<p>这就是完美主义的妄想性质：<strong>它让你爱上了一个不存在的理想版本，而不是专注于真实的创作过程</strong>。</p>\n<p>更有意思的是，完美主义者往往会在脑海中构建一个 “完美的自己”——这个自己永远不会犯错，永远能产出完美的作品，永远不需要修改和调整。就像园丁妄想中的小李幻想朋友来花园做客的场景一样，完美主义者也在幻想一个根本不存在的“完美状态”。</p>\n<p>结果呢？真实的创作变得痛苦不堪，因为每一个不完美的细节都在提醒你：现实与幻想之间的差距。</p>\n<h2>为什么完美主义更隐蔽</h2>\n<p>园丁妄想症相对容易识别，因为它的指向很明确：<strong>别人有的，我也想要</strong>。当你发现自己在模仿他人时，理性很容易介入。</p>\n<p>但完美主义不同。它披着&quot;追求卓越&quot;的外衣，社会文化还在不断强化这种价值观。<strong>“精益求精”、“不断进步”、“追求完美”</strong>——这些词汇听起来都那么正面，谁敢说自己反对呢？</p>\n<p>这种文化包装让完美主义变得极其隐蔽。你很难意识到自己陷入了一种妄想，因为周围的声音都在告诉你：这样做是对的。</p>\n<p>更糟糕的是，完美主义还有一个强大的自我欺骗机制：<strong>它总是能找到合理的理由</strong>。“我只是想把这件事做好”、“细节决定成败”、“我对自己要求高一点有什么错”——听起来都很有道理，不是吗？</p>\n<p>但问题在于，这种&quot;要求高&quot;往往脱离了现实的约束条件。就像文中的小李忘记了自己其实并不喜欢花一样，完美主义者也忘记了自己的真实目的是什么。</p>\n<h2>同样忽略过程的本质</h2>\n<p>原文提到，园丁妄想的核心问题是 “只看结果，忽略过程”。完美主义在这一点上如出一辙。</p>\n<p>完美主义者眼中只有那个完美的终点，对到达那里的路径却缺乏耐心。他们希望第一稿就是完美的，希望第一次尝试就成功，希望跳过所有笨拙和混乱的中间状态。</p>\n<p>这种对过程的厌恶导致了一个悖论：<strong>为了追求完美，他们反而拒绝了通往完美的唯一路径——不完美的练习</strong>。</p>\n<p>我自己写代码时就经常遇到这种情况。明明知道 “先让它跑起来，再让它跑得好” 的道理，但还是忍不住想要一次性写出 “完美” 的代码。结果往往是在架构设计上纠结半天，最后什么都没写出来。</p>\n<p>真正的创作过程永远是混乱的：第一稿是垃圾，第二稿还是垃圾，第三稿开始有点样子……这个过程既必要又痛苦，但完美主义者往往选择逃避这种痛苦。</p>\n<h2>相通的解决之道</h2>\n<p>既然完美主义本质上是一种「内在的园丁妄想」，那么原文的解决方案同样适用。</p>\n<p><strong>专注自己的花园</strong>，在完美主义语境下就是：<strong>专注真实的需求和过程，而不是虚幻的完美标准</strong>。</p>\n<p>原文提到的几个要点都很有启发：</p>\n<ol>\n<li><p><strong>审视动机</strong>：你追求完美是因为真的需要，还是因为恐惧？很多时候，完美主义源于对失败、批评或拒绝的恐惧，而不是对质量的真实需求。</p>\n</li>\n<li><p><strong>接受过程的不完美</strong>：就像邻居是从一两簇花开始，慢慢浇灌出花园一样，任何创作都需要从粗糙的开始逐步完善。</p>\n</li>\n<li><p><strong>关注内在热情</strong>：真正的园丁种花是因为喜欢，不是为了炫耀。真正的创作者写作是因为有话要说，不是为了证明自己完美。</p>\n</li>\n<li><p><strong>允许删除和舍弃</strong>：原文建议不要把冲动想法放进 GTD 系统，因为「如果一件事情对你来说真的重要，你的大脑会记住的」。同样，如果一个完美主义的标准让你痛苦而无产出，也许它根本就不重要。</p>\n</li>\n</ol>\n<h2>结语</h2>\n<p>我也在实践这个道理。我自知我的文笔不好，换做以前的自己可能根本不会选择去写个人博客。我不敢把自己不好的一面，或者说「未来的我看到会觉得像傻逼」的东西放出来。</p>\n<p>我现在正尝试努力克服自己的「不包容」：包容自己，包容他人。</p>\n<p>也许这就是摆脱&quot;园丁妄想症&quot;的真正含义，<strong>停止追逐虚幻的完美花园，开始享受真实的种植过程</strong>。</p>\n",
            "url": "https://quarkpixel.github.io/p/250810-perfectionism-also-kind-of-gardener-delusions",
            "title": "完美主义是否也是一种「园丁妄想症」？",
            "summary": "由 Eltrac 的文章《园丁妄想症》引发的思考。",
            "date_modified": "2025-08-10T07:25:00.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": []
        },
        {
            "id": "https://quarkpixel.github.io/p/250721-details-in-text-animation",
            "content_html": "<p>在<a href=\"./250525-tech-stack-in-hsuans-space\">之前的文章</a>中，我简单提到了自己开发的 <a href=\"https://github.com/QuarkPixel/svelte-text-animation\"><code>svelte-text-animation</code></a> 组件。这个组件最初是为了本站首页 Landing 部分的文字动画效果而设计的，后来觉得特别好用就抽象成了一个独立的组件。最近对组件进行了一些优化更新，借此机会来详细介绍一下这个库的实现细节。</p>\n<h2>核心设计思路</h2>\n<h3>基本原理</h3>\n<p>整个动画的核心思想非常简洁：<strong>使用高斯函数叠加边缘递减函数</strong>，为文本中的每个字符计算一个效果强度值，然后通过回调函数将这个强度转换为具体的样式。</p>\n<p><img src=\"https://raw.githubusercontent.com/QuarkPixel/svelte-text-animation/master/assets/example.gif\" alt=\"Demo\"></p>\n<h3>数学模型</h3>\n<p>动画效果由两个关键函数组成：</p>\n<ol>\n<li><strong>高斯函数</strong>：控制效果在文本中的空间分布</li>\n<li><strong>边缘递减函数</strong>：确保动画在起始和结束时平滑过渡</li>\n</ol>\n<h2>最新优化：更平缓的边缘递减函数</h2>\n<h3>原有实现的局限性</h3>\n<p>在之前的版本中，边缘递减函数使用的是简单的二次函数：</p>\n<p>$$\nf_{\\text{old}}(p) = 4p(1 - p)\n$$</p>\n<p>其中 $p$ 表示动画进度（progress）。这个函数确实能够满足边界条件：在 $p = 0$ 和 $p = 1$ 时函数值为 0，在 $p = 0.5$ 时达到最大值 $1$，实现了平滑过渡的目标。</p>\n<p>然而，这种实现存在一个显著问题：<strong>动画效果仅在进度接近 0.5 时才能完全展现，其他位置的效果都会被显著削弱</strong>。这意味着动画的大部分时间里，文字效果都无法达到理想状态。</p>\n<h3>新的数学方案</h3>\n<p>经过深入思考和数学推导，我设计了一个更高阶的多项式函数：</p>\n<p>$$\nf_{\\text{new}}(p) = 1 - (2p - 1)^{2n}\n$$</p>\n<p>其中 $n$ 对应新增的 <code>edgeFlatness</code> 参数（默认值为 5），用于控制函数的平缓程度。</p>\n<p>这个改进后的函数具有以下优秀特性：</p>\n<ul>\n<li><strong>保持边界条件</strong>：当 $p = 0$ 或 $p = 1$ 时，函数值依然为 $0$</li>\n<li><strong>峰值位置不变</strong>：在 $p = 0.5$ 时函数值仍为 $1$</li>\n<li><strong>中间区域显著改善</strong>：通过调整 $n$ 参数，可以让更大范围内的进度值都接近最大效果强度</li>\n</ul>\n<h3>函数特性分析</h3>\n<p>通过数学分析可以发现，当 $n = 1$ 时，新函数退化为原有的二次函数。而当 $n &gt; 1$ 时，函数变为 $2n$ 次多项式，相当于在原有基础上增加了一个可调节的平缓度参数。</p>\n<center>\n<img class=\"outline outline-[#26796D] outline-3 w-[50%]\" src=\"/img/250721-0.gif\" alt=\"edgeFactor 函数演示\" data-libra />\n<em>不同 flatness 值下的边缘递减函数对比</em>\n</center>\n\n<p>从图中可以直观看出，随着 <code>flatness</code> 参数的增大，函数在中间区域变得更加平缓，这意味着动画效果在更大的进度范围内都能保持接近最大强度，显著提升了整体的视觉表现。</p>\n<h2>核心实现解析</h2>\n<h3>效果强度数组生成算法</h3>\n<pre><code class=\"language-typescript\">function generateEffectArray(\n\tlength: number,\n\tprogress: number,\n\tspread: number,\n\tflatness: number\n): number[] {\n\t// 计算边缘递减因子\n\tconst edgeFactor = 1 - Math.pow(2 * progress - 1, 2 * flatness);\n\tconst result = new Array(length).fill(0);\n\n\t// 早期返回优化：当边缘因子为负时直接返回零数组\n\tif (edgeFactor &lt;= 0) {\n\t\treturn result;\n\t}\n\n\t// 计算当前动画焦点在文本中的位置\n\tconst offset = progress * (length + 2 * spread + 1) - spread - 1;\n\n\t// 优化计算范围，避免不必要的高斯函数计算\n\tconst startIdx = Math.max(0, Math.floor(offset - spread * 3));\n\tconst endIdx = Math.min(length - 1, Math.ceil(offset + spread * 3));\n\n\tfor (let i = startIdx; i &lt;= endIdx; i++) {\n\t\tconst z = (i - offset) / spread;\n\t\tconst zSquared = z * z;\n\n\t\t// 性能优化：当 z² &gt; 9 时，e^(-z²) &lt; 0.01，可以忽略\n\t\tif (zSquared &lt; 9) {\n\t\t\tresult[i] = Math.exp(-zSquared) * edgeFactor;\n\t\t}\n\t}\n\n\treturn result;\n}\n</code></pre>\n<h3>关键优化策略</h3>\n<ol>\n<li><strong>早期返回优化</strong>：当边缘因子小于等于 0 时，直接返回零数组，避免后续无意义的计算</li>\n<li><strong>智能范围限制</strong>：仅对可能产生显著效果的字符范围进行计算，大幅降低计算复杂度</li>\n<li><strong>高斯函数截断</strong>：利用指数函数的快速衰减特性，当距离过远时直接跳过计算</li>\n</ol>\n<h2>API 设计</h2>\n<h3>核心参数接口</h3>\n<pre><code class=\"language-typescript\">interface Props {\n\ttext: string;                                 // 要进行动画的文本内容\n\tprogress: number;                             // 动画进度，取值范围 [0, 1]\n\tspread?: number;                              // 效果扩散半径，默认 3\n\tedgeFlatness?: number;                        // 边缘平缓度，默认 5\n\tstyleCallback: (intensity: number) =&gt; string; // 强度到样式的转换函数\n\tinnerClassName?: string;                      // 字符容器的 CSS 类名\n}\n</code></pre>\n<h3>实际使用示例</h3>\n<pre><code class=\"language-svelte\">&lt;TextAnimation\n    text=&quot;Hello, World!&quot;\n    {progress}\n    spread={4}\n    edgeFlatness={6}\n    styleCallback={(intensity) =&gt; `\n        transform: scale(${1 + intensity * 0.5});\n        color: rgb(${255}, ${Math.floor(255 * intensity)}, ${Math.floor(255 * intensity)});\n    `}\n/&gt;\n</code></pre>\n<p>你可以在 <a href=\"https://svelte.dev/playground/434018293cfb415b925f19b47ef4a85c?version=5.33.1\">Svelte Playground</a> 中直接体验这个组件的效果。</p>\n<p>实际应用场景可以参考本博客首页的 Landing 部分，对应的源码实现：<a href=\"https://github.com/QuarkPixel/QuarkPixel.github.io/blob/master/src/routes/Landing.svelte\">Landing.svelte</a>。</p>\n<hr>\n<h2>总结</h2>\n<p><code>svelte-text-animation</code> 通过精心设计的数学函数组合，实现了既平滑又视觉效果出色的文字动画。最新版本中边缘递减函数的优化，通过引入可调节的平缓度参数，显著提升了动画在整个进度范围内的表现效果。</p>\n<p>这种基于数学模型的设计方法不仅保证了动画的流畅性，还为开发者提供了充分的自定义空间。如果你对这个组件感兴趣，欢迎在 <a href=\"https://github.com/QuarkPixel/svelte-text-animation\">GitHub</a> 上为项目点个 Star 😆</p>\n",
            "url": "https://quarkpixel.github.io/p/250721-details-in-text-animation",
            "title": "TextAnimation 的实现细节",
            "summary": "深入解析 svelte-text-animation 组件的技术实现与最新优化",
            "date_modified": "2025-07-21T12:44:11.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "['Technique'",
                "'Web']"
            ]
        },
        {
            "id": "https://quarkpixel.github.io/p/250720-is-hdr-being-overused",
            "content_html": "<script>\nimport BiliPlayer from '$lib/components/BiliPlayer.svelte';\n</script>\n\n<p><strong>这是一篇讨论帖，由于本人没有实际上手过新的操作系统，故所有内容均来自网络，内容可能有误。欢迎发表自己的看法～</strong></p>\n<h2>引言</h2>\n<p>起因来自一条视频，展示了 Apple 在新系统的画笔中支持选择 <a href=\"https://en.wikipedia.org/wiki/High_dynamic_range\">HDR</a> 颜色。</p>\n<BiliPlayer bv=\"BV1TW33zdE2T\" />\n\n<p>给我的第一感受就是：<strong>怪</strong>。</p>\n<p>我其实能理解为什么 Apple 会允许选择 HDR 颜色，让系统整体对 HDR 有更深度的融合。但我不禁要问：这样的 HDR 真的合理吗？设计生态真的准备好了吗？</p>\n<p>我的担心是：HDR 技术为 UI 带来了更丰富的视觉表现力，但在缺乏统一设计语言和生态支持的前提下，Apple 等厂商的 &quot;开放式 HDR\n策略&quot; 反而可能破坏用户界面的一致性，增加设计负担。</p>\n<h2>HDR 的潜力</h2>\n<p>HDR 如果处理得好的话，UI 确实可以美到飞起。</p>\n<p>HDR 不只是让画面更亮、更艳，更重要的是它为界面设计引入了 &quot;亮度空间&quot; 这一新的表达维度。从传统的颜色/对比度控制，拓展到了真实光强的建构。得益于此，HDR\n可作为界面结构化、分层与焦点引导的新工具。例如：</p>\n<ul>\n<li><p>通过局部高亮引导用户注意力，而非依赖颜色或动画；</p>\n</li>\n<li><p>模拟真实光源制造视觉层次感，从而增强沉浸体验；</p>\n</li>\n<li><p>赋予 UI 元素不同的“光学存在感”，区分主次关系。</p>\n</li>\n</ul>\n<p>这些观点指向一个共识：<strong>HDR 是视觉强化的强力工具，但前提是 &quot;设计得好&quot; ，且配合统一的设计语言与生态标准。</strong> 否则，它也可能成为破坏体验的利器。</p>\n<h2>问题在于 HDR 没有统一标准</h2>\n<p>但现实情况是，我们的 HDR UI 体验远没有达到理想状态。</p>\n<h3>系统层面的设计不一致</h3>\n<p>最明显的问题是视觉连贯性的缺失。我们经常能看到 HDR 视频在普通 UI 界面上播放，导致整体界面看起来发灰、不协调。这种 &quot;接缝感&quot;\n破坏了用户界面应有的统一性。</p>\n<p>还有 Reddit\n用户提到 <a href=\"https://www.reddit.com/r/appletv/comments/x2al6l/youtube_adverts_causing_huge_delay_because_tv/\">YouTube 广告因 HDR 切换导致画面延迟和色彩跳变</a>\n，严重影响观看体验。</p>\n<p>这些问题的根源在于：<strong>HDR 在系统 UI 中的体验不连贯，打断了用户的视觉流，这是设计上的失败。</strong></p>\n<h3>缺乏设计指导下的 &quot;自由发挥&quot;</h3>\n<p>当技术门槛降低，HDR 变得人人可用时，缺乏设计规范的约束就会带来问题。</p>\n<p>我们确实看到了一些令人担忧的现象：抖音上有用户开始使用带有HDR高亮的表情包进行恶搞，这些内容因为比平常的图片更亮而获得关注。</p>\n<details>\n  <summary>[视频] 这年头，表情包都自带HDR了？</summary>\n  <BiliPlayer bv=\"BV1HkTuzcE7V\" />\n</details>\n\n<p>类似的情况还出现在广告投放中，HDR被用作粗暴的注意力抓取工具，而不是精心设计的视觉体验。这些现象本身不是核心问题，而是设计缺位的副作用。</p>\n<details>\n  <summary>[视频] 野生的网页 HDR 广告</summary>\n  <BiliPlayer bv=\"BV1sw4m1d7L1\" />\n</details>\n\n\n<p><strong>HDR UI 当前的问题不是 HDR 本身，而是没有明确的 &quot;设计语言&quot; 和规范来驾驭它。</strong></p>\n<h3>生态支持的不成熟</h3>\n<p>更深层的问题在于，我们的数字生态还没有准备好迎接 &quot;全面HDR化&quot;。</p>\n<p>第三方应用、浏览器、视频播放器对 HDR 的支持参差不齐，导致用户在不同场景下体验到的 HDR 效果千差万别。有时候 HDR\n让界面更加精致，有时候又让整体显得突兀。这种不可预测性正是设计大忌。</p>\n<p>Steam 社区论坛上有用户抱怨 <a href=\"https://steamcommunity.com/discussions/forum/11/7074686901648727412/\">HDR 显示器效果的糟糕</a>\n，虽然不知道具体的原因，但我们可以明确的是现在的 HDR 领域无比混乱。</p>\n<h2>结语</h2>\n<p>回到开头的问题：Apple 开放 HDR 究竟是好事还是坏事？</p>\n<p>我的观点是：<strong>HDR是好工具，但应该被认真对待。</strong></p>\n<p>我们需要的不是 HDR 的全面开放，而是有设计指导的 HDR 应用。Apple 等厂商在推广 HDR 技术时，应该投入更多精力建立统一的设计规范和使用标准；软件厂商在对接\nHDR 技术时，也更应该谨慎对待。</p>\n<h2>参考文章</h2>\n<ul>\n<li><a href=\"https://medium.com/design-bootcamp/what-hdr-in-ui-tells-us-about-the-future-of-digital-perception-bb3d9133d1f6\">HDR in UI: Designing Perception Through\nBrightness</a></li>\n<li><a href=\"https://medium.com/design-bootcamp/the-rise-of-hdr-ui-not-a-visual-gimmick-but-a-paradigm-shift-in-perceptual-logic-8062247f72dd\">HDR UI and EDR: Rethinking Brightness in Interface Design</a></li>\n<li><a href=\"https://medium.com/design-bootcamp/is-your-ui-design-file-still-representing-the-final-output-in-the-hdr-ui-era-4bd4fb1f4b9d\">Is Your UI Design File Still Representing the Final Output in the HDR UI Era?</a></li>\n</ul>\n",
            "url": "https://quarkpixel.github.io/p/250720-is-hdr-being-overused",
            "title": "HDR 在被滥用吗",
            "summary": "谈谈现今 HDR 的一些问题",
            "date_modified": "2025-07-20T11:24:30.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "[ 'Thinking'",
                "'Visual' ]"
            ]
        },
        {
            "id": "https://quarkpixel.github.io/p/250712-summer-clouds",
            "content_html": "<p><strong>夏日的云，也想慵懒。</strong></p>\n<p>平时喜欢去天台散心：没有喧嚣，只有自己。夏日的云和其它时候都不一样。从专业术语的角度出发，我爱看夏天的<a href=\"https://zh.wikipedia.org/wiki/%E7%A7%AF%E4%BA%91\">积云</a>。记这些年来拍到的夏日云：</p>\n<div class=\"bg-surface-100-900 outline-9 rounded-xl my-2 outline-surface-100-900 grid grid-cols-3 grid-rows-6 gap-2 [&_img]:w-full [&_img]:h-full [&_img]:object-cover [&_img]:m-0 *>rounded-xl *>shadow-lg *>overflow-hidden *>bg-gray-200\">\n  <div data-libra class=\"col-start-1 col-span-2 row-start-1 row-span-2\">\n    <img alt=\"clouds\" src=\"https://images.unsplash.com/photo-1696332223628-62631dabb337\"/>\n  </div>\n\n  <div class=\"col-start-3 col-span-1 row-start-1 row-span-3\">\n    <img alt=\"clouds\" src=\"https://images.unsplash.com/photo-1696332223533-993114881882\"/>\n  </div>\n\n  <div class=\"col-start-1 col-span-1 row-start-3 row-span-3\">\n    <img alt=\"clouds\" src=\"https://images.unsplash.com/photo-1696332223583-0d94cb2911f7\"/>\n  </div>\n\n  <div class=\"col-start-2 col-span-2 row-start-4 row-span-1\">\n    <img alt=\"clouds\" src=\"https://images.unsplash.com/photo-1695450148576-675cab2c9215\"/>\n  </div>\n\n  <div class=\"col-start-2 col-span-1 row-start-3 row-span-1\">\n    <img alt=\"clouds\" src=\"https://images.unsplash.com/photo-1696332223520-1278796028f5\"/>\n  </div>\n\n  <div class=\"col-start-3 col-span-1 row-start-5 row-span-2\">\n    <img alt=\"clouds\" src=\"https://images.unsplash.com/photo-1696332222129-6e44eb7e3f29\"/>\n  </div>\n\n  <div class=\"col-start-2 col-span-1 row-start-5 row-span-2\">\n    <img alt=\"clouds\" src=\"https://images.unsplash.com/photo-1727843062665-040b10410226\"/>\n  </div>\n\n  <div class=\"col-start-1 col-span-1 row-start-6 row-span-1\">\n    <img alt=\"clouds\" src=\"https://images.unsplash.com/photo-1696332223050-253b7b199a68\"/>\n  </div>\n</div>\n<div class=\"-mt-1\"><a class=\"text-surface-400-600 font-noto-sans text-sm\" href=\"https://unsplash.com/@quarkpixel\">Unsplash @quarkpixel</a></div>\n",
            "url": "https://quarkpixel.github.io/p/250712-summer-clouds",
            "title": "夏长，云懒。",
            "summary": "记录平时拍摄的云",
            "date_modified": "2025-07-12T07:15:00.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "[ 'Photography' ]"
            ]
        },
        {
            "id": "https://quarkpixel.github.io/p/250701-remake-typography",
            "content_html": "<p>许久之前就无法忍受网页的排版。作为一个博客网站，文字的呈现效果是至关重要的。在之前介绍<a href=\"./250525-tech-stack-in-hsuans-space\">网站使用的技术栈</a>时就提到我使用了 Skeleton 作为 UI 框架。然而这个框架在排版方面的表现很不尽如人意。我趁着最近在大量升级网站的机会，将排版系统从 Skeleton + MDsveX 自定义样式转向了 Tailwind Typography + MDsveX 默认对接。</p>\n<center>\n<img class=\"outline outline-[#808CA9] outline-4 rounded-[1px] mb-[44px]\" src=\"/img/250701-0.webp\" alt=\"\" data-libra/>\n<em>左图：新版｜右图：老版</em>\n</center>\n\n<h2>使用 Skeleton 所遇到的问题</h2>\n<p><a href=\"https://skeleton.dev/\">Skeleton</a> 是一个非常优秀的 UI 框架，它为 SvelteKit 提供了美观且功能丰富的组件库。在构建网站的导航栏、按钮、卡片等常规 UI 组件时，Skeleton 的表现令人满意。</p>\n<p>然而，当面对大量文字排版这样的特定场景时，Skeleton 就不再能胜任。它更着重于 UI，而非排版。在此之前我因为偷懒，就没有想着用专业的排版引擎 😂</p>\n<p>此外，即使作为一个 UI 组件集，我认为 Skeleton 在排版方面也远不算合格。它不基于语义化标签作用样式，甚至还将语义化标签的样式都重置了。因此当你直接使用 <code>&lt;h1&gt;</code> 时，它是没有任何样式的。这是因为 Skeleton 要求你为每个标题添加对应的 class：</p>\n<pre><code class=\"language-html\">&lt;!-- 没有样式，因为缺少 class --&gt;\n&lt;h1&gt;Hello World&lt;/h1&gt;\n\n&lt;!-- “正确” 的使用方式，但很难评 --&gt;\n&lt;h1 class=&quot;h1&quot;&gt;Hello World&lt;/h1&gt;\n</code></pre>\n<p>而这在与 MDsveX 对接时就产生了问题：MDsveX 只生成纯 HTML 结构，这在与 Skeleton 的对接中就出现了问题。因此我不得不为每一个基本元素都写一个包装组件：</p>\n<pre><code class=\"language-bash\">➜ HsuansSpace/src/lib/components/typography master ✓ tree .\n.\n├── Anchor.svelte\n├── BaseList.svelte\n├── Blockquote.svelte\n├── Code.svelte\n├── Del.svelte\n├── H1.svelte\n├── H2.svelte\n├── H3.svelte\n├── H4.svelte\n├── H5.svelte\n├── H6.svelte\n├── Hr.svelte\n├── Ins.svelte\n├── Italic.svelte\n├── Keyboard.svelte\n├── Mark.svelte\n├── OrderedList.svelte\n├── P.svelte\n├── Pre.svelte\n├── Table.svelte\n├── TableBody.svelte\n├── UnorderedList.svelte\n└── index.ts\n\n1 directory, 24 files\n</code></pre>\n<p>抛去麻烦的问题外，还有一些样式的不兼容等问题就在这样一层又一层的屎山中构建起来了。</p>\n<h2>转换为 Tailwind Typography</h2>\n<p><a href=\"https://tailwindcss.com/docs/typography-plugin\">Tailwind Typography</a> 是一个官方专门为文章排版设计的插件。它提供了：</p>\n<ul>\n<li>精心调教的文字间距和行高</li>\n<li>优雅的标题层级样式</li>\n<li>完善的列表和引用样式</li>\n<li>适配不同屏幕尺寸的响应式排版</li>\n</ul>\n<p>最重要的是，Tailwind Typography 完全基于语义化标签工作，与 MDsveX 的默认渲染完美契合。这意味着我们可以专注于写作内容，不必再为每个 HTML 标签编写包装组件，因为屎山堆叠所导致的样式错误问题也消失了。</p>\n<h2>迁移过程</h2>\n<p>迁移过程出乎意料地顺利。主要步骤包括：</p>\n<ol>\n<li>移除 Skeleton 中的文章样式覆盖</li>\n<li>配置 Tailwind Typography 插件</li>\n<li>为文章容器添加 <code>prose</code> 类</li>\n<li>调整默认颜色配置，使其适配 Skeleton 的颜色系统</li>\n</ol>\n<h2>总结</h2>\n<p>有时候，简单的解决方案反而是最好的。Tailwind Typography 专注于解决文章排版这一具体问题，而不是试图成为一个全能的框架。这让它在这个特定场景下的表现远超 Skeleton。</p>\n<p>你可以在这里查看完整的 <a href=\"/test\">Markdown 语法测试</a>，体验新的排版效果。</p>\n",
            "url": "https://quarkpixel.github.io/p/250701-remake-typography",
            "title": "重做网页布局排版",
            "summary": "从 Skeleton 转向 Tailwind Typography",
            "date_modified": "2025-07-01T07:15:00.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "[ 'Develop Diary' ]"
            ]
        },
        {
            "id": "https://quarkpixel.github.io/p/250629-new-rss-feature",
            "content_html": "<p>为博客添加了 RSS 订阅功能！🎉</p>\n<p>现在你可以通过 RSS 阅读器订阅本博客的更新了。支持以下几种订阅格式：</p>\n<ul>\n<li><a href=\"/feed/rss.xml\">RSS 2.0</a></li>\n<li><a href=\"/feed/atom.xml\">Atom</a></li>\n<li><a href=\"/feed/feed.json\">JSON Feed</a></li>\n</ul>\n<p>RSS（Really Simple Syndication）是一种很棒的信息获取方式。通过 RSS，你可以在自己喜欢的阅读器中统一管理和阅读订阅的内容，不会错过任何更新，也不用担心算法推荐的干扰。</p>\n<p>此外，网站更新的内容还有：</p>\n<ul>\n<li>Footer 的重置***（新版本的效果我很满意😁）***</li>\n<li>友链支持</li>\n<li>网站后台监控***（使用 <a href=\"https://umami.is\">Umami</a> 服务）***以及更新 <a href=\"/privacy\">隐私政策</a></li>\n<li>首页 Landing 现在可以鼠标交互了✨</li>\n</ul>\n<p>欢迎订阅本博客的 RSS feed！📮</p>\n",
            "url": "https://quarkpixel.github.io/p/250629-new-rss-feature",
            "title": "支持 RSS 订阅啦！",
            "summary": "添加 RSS Feed 支持，以及其他方面的网站改进",
            "date_modified": "2025-06-29T00:00:00.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "[ 'Develop Diary' ]"
            ]
        },
        {
            "id": "https://quarkpixel.github.io/p/250623-rust-is-suitable-for-vibe-coding",
            "content_html": "<p><del>(文章标题有些暴论，李姐万岁)</del></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Vibe_coding\">Vibe Coding</a> 是一种借助 AI 生成代码，并通过人机协作快速验证和迭代想法的开发方式。在这种模式下，开发效率高度依赖于两个关键环节：生成代码的初步质量，以及后续验证与修正的可靠性。而 Rust 的诸多语言特性，恰恰能够在这两个环节中提供显著支持。</p>\n<h2>语言特性的安全保障</h2>\n<p>AI 生成的代码往往存在潜在缺陷，尤其在内存管理、并发控制和边界条件处理等方面容易出现疏漏。考虑这样一个常见场景，生成如下的 C++ 代码：</p>\n<pre><code class=\"language-cpp\">// 存在悬垂指针风险\nint* createInt() {\n    int value = 42; // 局部变量，函数结束时销毁\n    return &amp;value;  // 返回局部变量的地址\n}\n</code></pre>\n<p>这段代码在运行时可能导致未定义行为，而编译器往往只会给出警告，甚至完全不报错。但如果 AI 试图在 Rust 中生成类似的代码：</p>\n<pre><code class=\"language-rust\">fn create_int() -&gt; &amp;i32 {\n    let value = 42; // 局部变量\n    &amp;value // 错误：返回局部变量的引用\n}\n</code></pre>\n<p>Rust 编译器会直接拒绝编译，并给出明确的生命周期错误提示：</p>\n<pre><code>error[E0106]: missing lifetime specifier\n --&gt; src/main.rs:1:20\n  |\n1 | fn create_int() -&gt; &amp;i32 {\n  |                    ^ expected named lifetime parameter\n  |\n  = help: this function&#39;s return type contains a borrowed value, but there is no value for it to be borrowed from\nhelp: consider using the `&#39;static` lifetime, but this is uncommon unless you&#39;re returning a borrowed value from a `const` or a `static`\n  |\n1 | fn create_int() -&gt; &amp;&#39;static i32 {\n  |                     +++++++\nhelp: instead, you are more likely to want to return an owned value\n  |\n1 - fn create_int() -&gt; &amp;i32 {\n1 + fn create_int() -&gt; i32 {\n  |\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `demo_rust` (bin &quot;demo_rust&quot;) due to 1 previous error\n</code></pre>\n<p>Rust 的所有权系统、借用检查机制和严格的类型系统，能够在编译阶段拦截许多常见错误。这不仅显著降低了运行时崩溃的风险，也使得 AI 即使生成出不够完善的代码，仍能在编译器指导下逐步逼近正确实现。</p>\n<h2>人性化的错误提示</h2>\n<p>Rust 编译器所提供的错误信息一向以清晰、详尽而著称。它不只是告诉你「错了」，而是手把手教你「该怎么改」。就像上面的例子中，编译器不仅指出了生命周期问题，还直接建议了两种修复方案：使用 <code>&#39;static</code> 生命周期或返回拥有值。这种详细的错误信息，甚至包含了修复建议，让 AI 能够自主进行多轮修正。开发者则可以将精力集中于更高层的逻辑设计，而不必深入调试每一个低级错误。</p>\n<p>相比之下，C++ 的错误信息往往会让人摸不着头脑：</p>\n<pre><code>main.cpp:5:13: warning: address of stack memory associated with local variable &#39;value&#39; returned [-Wreturn-stack-address]\n    return &amp;value;  // 返回局部变量的地址\n            ^~~~~\n1 warning generated.\n</code></pre>\n<p>这样的错误信息对 AI 和开发者都不够友好，即使 AI 大部分时候可以像经验丰富的开发者一样知道问题出现的原因，但这种模糊的提示仍然增加了调试成本。</p>\n<h2>编译时检查作为自动化验证</h2>\n<p>传统 Vibe Coding 流程中，代码的正确性严重依赖人工测试与审查，这不仅效率低下，也容易引入主观偏差。而 Rust 的编译时检查机制（包括类型安全、生命周期验证、数据竞争检测等）构成了一套自动化、标准化的验证基础。它确保了生成的代码至少在内存安全、数据竞争等基础层面是可信的，从而为后续的功能测试和集成验证节省大量时间。</p>\n<p>举个例子，在多线程场景中，即使 AI 生成了可能存在数据竞争的代码，Rust 编译器也会在编译阶段就将其拦截，并引导向使用 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 或其他合适的同步原语的正确方案。这种&quot;编译通过即基本安全&quot;的特性，在快速原型开发中尤为宝贵。</p>\n<h2>类型系统的引导作用</h2>\n<p>Rust 的类型系统还能够引导 AI 生成更加精确的代码。例如，当处理可能失败的操作时，Rust 的 <code>Result</code> 类型会强制处理错误情况，而不像某些动态语言那样可以随意忽略异常处理。这种「强制正确性」的设计哲学，与 AI 编程中「快速迭代但保证质量」的需求高度契合。</p>\n<h2>局限性和现状</h2>\n<p>目前，Python 和 JavaScript 在 Vibe Coding 中确实更加普及，主要原因在于它们的生态丰富度和语法简洁性。动态类型语言在原型开发阶段确实更加灵活，而且 AI 训练数据中这些语言的代码占比很大。相比之下，Rust 的学习资源和代码语料仍然相对有限，这在一定程度上限制了 AI 模型对 Rust 的支持深度。</p>\n<p>不过，随着 Rust 在系统编程、Web 开发和区块链等领域的快速发展，以及 Microsoft、Google 等大厂的推动，这一差距正在逐渐缩小。</p>\n<h2>结论</h2>\n<p>Rust 通过其内在的安全机制、友好的诊断信息以及强大的编译时验证，为 Vibe Coding 提供了一条兼具高可靠性和自动化程度的开发路径。虽然它可能不如 Python 那样&quot;即写即跑&quot;，但在需要高质量、可维护代码的场景中，Rust 的这些特性能够显著提升人机协作的效率和成果质量。</p>\n<p>随着 AI 编程工具的不断发展和 Rust 生态的日益成熟，我相信会有越来越多的开发者发现：让 AI 在 Rust 的约束下编写代码，往往能够得到更加可靠和优雅的解决方案。这种&quot;约束即自由&quot;的开发体验，也许正是未来 AI 辅助编程的理想形态。</p>\n",
            "url": "https://quarkpixel.github.io/p/250623-rust-is-suitable-for-vibe-coding",
            "title": "Rust 是一门适合 Vibe Coding 的语言",
            "summary": "从安全特性、错误提示和自动化验证的角度，探讨为什么 Rust 可能是最适合 AI 编程的语言",
            "date_modified": "2025-06-23T00:00:00.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "['Rust'",
                "'AI']"
            ]
        },
        {
            "id": "https://quarkpixel.github.io/p/250616-new-giscus-module",
            "content_html": "<p>终于给博客加上了评论功能！🎉</p>\n<p>选用了 <a href=\"https://giscus.app/\">giscus</a> 作为评论系统，它基于 GitHub Discussions，完全开源且免费。最重要的是，它支持 Markdown 语法，可以让我们能更好地交流想法。</p>\n<p>现在，你可以在每篇文章的底部看到评论区了。欢迎来聊聊天呀～</p>\n",
            "url": "https://quarkpixel.github.io/p/250616-new-giscus-module",
            "title": "上线评论功能～",
            "summary": "添加基于 Giscus 的评论系统",
            "date_modified": "2025-06-16T00:00:00.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "[ 'Develop Diary' ]"
            ]
        },
        {
            "id": "https://quarkpixel.github.io/p/250609-the-trolley-problem-and-suicide",
            "content_html": "<p>最近我在思考一个问题：电车难题的选择与阻止自杀的抉择是否有着相似的本质？</p>\n<h2>引子：一个假设性思想实验</h2>\n<p>最初的思考源于一个假设：</p>\n<blockquote>\n<p>假设世界有这样一条设定**（尽管价值观未必正确，但有助于讨论）<strong>：存在天堂，只有通过自杀</strong>（主观选择死亡）**的人因其&quot;勇敢&quot;而获得更好的待遇，而非自主死亡的人则命运平庸。</p>\n<p>在此设定下，一个人选择自杀，另一人阻止他，是否正确？</p>\n</blockquote>\n<p>这看似荒谬，但换个角度思考：<strong>选择自杀的人往往因极度痛苦而寻求解脱</strong>。自杀对他们而言，如同进入&quot;天堂&quot;或摆脱苦难。从这点看，自杀的动机与&quot;天堂假设&quot;殊途同归：主体都追求更好的结果。</p>\n<p>但前提是，若自杀未遂，生活未改善，痛苦依旧。关键问题是：<strong>若救下自杀者却无法善待他，阻止自杀是否成了错误？</strong></p>\n<h2>与电车难题的类比</h2>\n<p>我们可以将此与<strong>电车难题</strong>类比：</p>\n<ul>\n<li><strong>一人（自杀者）</strong>：若不拉杆**（不阻止自杀）<strong>，他得以&quot;解脱&quot;</strong>（如同进入天堂或摆脱痛苦）**</li>\n<li><strong>五人（在意他的人）</strong>：泛指任何得知自杀后会伤心的人，如亲友</li>\n<li><strong>抉择</strong>：拉杆**（阻止自杀）<strong>亦或不拉杆</strong>（放任自杀）**</li>\n</ul>\n<h2>道德权衡的复杂性</h2>\n<p>由此，问题转化为：</p>\n<p><strong>不拉杆</strong>：自杀者解脱，但在意他的人因失去他而痛苦。</p>\n<p><strong>拉杆</strong>：自杀者被救下，若未被善待，则继续痛苦；在意他的人免于悲伤。</p>\n<p>阻止自杀的人做错了吗？我的答案是：<strong>没有</strong>。他只是做出了电车难题中的选择，权衡了个体解脱与他人的情感损失。同样，若有人选择不阻止自杀，也不应苛责，因为这也是基于个人价值观的决定。</p>\n<h2>我们早已做出的选择</h2>\n<p>那么，对于电车难题中的拉杆抉择，我们是否早已在生活中做出了选择？</p>\n<p>在&quot;被救者未被善待&quot;的前提下，阻止自杀可能让痛苦延续，类似电车难题中牺牲一人救多数的道德困境。然而，若救下的人能被善待，痛苦得以缓解，这场抉择的意义便截然不同。</p>\n<h2>结语</h2>\n<p>或许，电车难题与阻止自杀的共通之处在于：我们都在有限的信息与复杂的道德权重中挣扎。拉杆与否，没有绝对的正误，<strong>关键在于后续的善待能否实现</strong>。</p>\n<p>如果我们能确保救下的灵魂被温柔以待，电车难题的拉杆，或许早已有了答案。否则，我们的选择可能只是将痛苦从一方移到另一方，永远在伦理的灰色地带徘徊。</p>\n",
            "url": "https://quarkpixel.github.io/p/250609-the-trolley-problem-and-suicide",
            "title": "也许我们早已在电车难题中做出了选择？",
            "summary": "聊聊阻止自杀与电车难题",
            "date_modified": "2025-06-09T00:00:00.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "['Thinking']"
            ]
        },
        {
            "id": "https://quarkpixel.github.io/p/250525-tech-stack-in-hsuans-space",
            "content_html": "<p>关于「我要做一个关于自己的网页」这个 Flag 我已经立了若干年了，最近这段时间终于有动力来完成它。尝试了没有接触过的技术，花了近半个月的时间，完成了网页的搭建。</p>\n<p><img src=\"https://wakatime.com/badge/user/018b19a3-343c-48f6-8ba9-5713e3a014cc/project/e4f1a103-1fe2-4a7b-afe8-35b4df2164b6.svg?style=flat-square\" alt=\"Wakatime badage\">\n<em>Time in this web project over all time</em></p>\n<p>本站采用了现代化的 Web 开发技术栈，主要包括：SvelteKit、TailwindCSS、MDsveX 和 Skeleton UI.</p>\n<h2>1. 字体</h2>\n<p>正文部分使用 <a href=\"https://github.com/lxgw/LxgwWenKai\">霞鹜文楷</a>。</p>\n<h4>其余字体</h4>\n<ul>\n<li>Noto Serif SC Variable</li>\n<li>Noto Sans SC Variable</li>\n<li>Caveat Variable</li>\n<li>Gravitas One</li>\n</ul>\n<p>值得注意的是，本网站使用了<a href=\"https://chinese-font.netlify.app/zh-cn/online-split/\">字体分包</a>技术，由<a href=\"https://chinese-font.netlify.app/zh-cn/\">中文网字计划</a>支持。因此在初次访问网站时，字体会有很独特的加载顺序。</p>\n<h2>2. 动画</h2>\n<h3>可变字体动画</h3>\n<p>使用自己做的另外一款组件<a href=\"https://github.com/QuarkPixel/svelte-text-animation\"><code>svelte-text-animation</code></a>，这款组件的开发是在网页的开发过程中想到的灵感，就花了差不多一个下午的时间来实现。整体效果还是很惊艳的，用在了首页 Landing\n的部分 😆。</p>\n<p>具体实现的细节其实很是很简单的，使用一个高斯函数叠加上一个边缘递减函数，就可以实现一个平滑的动画效果。</p>\n<h3>Logo 动画</h3>\n<p>我尝试了市面上很多的 SVG 动画库，但是要么就是太过臃肿，要么就是实现的效果很奇怪，没法做到我要求的“点对点移动”的效果。于是我心一狠，直接手撕了一个SVG动画引擎。其实实际实现起来，没有想象的那么复杂。这也多亏了\nSvelte 大量的内置函数，使用起来体验很不错。</p>\n<script>\n    import Logo from '$lib/components/Logo.svelte';\n    import { bounceOut, elasticOut } from 'svelte/easing';\n\tlet logoOfficial = true;\n</script>\n\n<p>&lt;button\n  class=&quot;mt-20 mb-3 w-full flex justify-around gap-10 _:h-30 _:w-40&quot;\n  onmouseenter={() =&gt; logoOfficial = false}\n  onmouseleave={() =&gt; logoOfficial = true}</p>\n<blockquote>\n</blockquote>\n<pre><code>&lt;Logo\n    official={logoOfficial}\n    easing={elasticOut}\n/&gt;\n&lt;Logo\n    official={logoOfficial}\n/&gt;\n&lt;Logo\n    official={logoOfficial}\n    easing={bounceOut}\n/&gt;\n</code></pre>\n</button>\n\n<div align=\"center\" class=\"mb-15 opacity-65 font-gravitas-one\">↑ Hover Me ↑</div>\n\n<h4>核心代码：</h4>\n<pre><code class=\"language-typescript\">// Derive interpolated path coordinates\nlet interpolatedPaths: Shape[] = $derived(\n\tpaths.map((path) =&gt;\n\t\tpath.initial.map((start, i) =&gt; {\n\t\t\tconst end = path.target[i];\n\t\t\tconst x = start[0] + (end[0] - start[0]) * path.tween.current;\n\t\t\tconst y = start[1] + (end[1] - start[1]) * path.tween.current;\n\t\t\treturn [x, y];\n\t\t})\n\t)\n);\n\n// Derive SVG path d attributes\nlet dValues: string[] = $derived(\n\tinterpolatedPaths.map((points) =&gt; `M${points.map((point) =&gt; point.join(&#39; &#39;)).join(&#39;L&#39;)}Z`)\n);\n</code></pre>\n<h3>Header 的背景噪声图</h3>\n<p>具体实现是使用一张噪声纹理图</p>\n<center>\n<p>\n    <img src=\"/assets/noise-texture.png\" alt>\n    <em>噪声纹理图</em>\n</p>\n</center>\n\n<h5>但由于不同屏幕尺寸可能会导致纹理图发糊。因此我做了这些工作：</h5>\n<ul>\n<li>添加属性 <code>image-rendering: pixelated;</code>，具体属性说明参见<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering\">MDN</a></li>\n<li>动态计算图片展示大小，使得图片可以1:1像素展示在显示器上：</li>\n</ul>\n<pre><code class=\"language-typescript\">function calcNoiseSize() {\n\tconst dpr = window.devicePixelRatio || 1;\n\tnoiseTextureSize = NOISE_TEXTURE_SIZE / dpr;\n}\n\nif (browser) {\n\tcalcNoiseSize();\n}\n\nonMount(() =&gt; {\n\twindow.addEventListener(&#39;resize&#39;, calcNoiseSize);\n\n\treturn () =&gt; window.removeEventListener(&#39;resize&#39;, calcNoiseSize);\n});\n</code></pre>\n<h3>Marquee</h3>\n<p>页面内所有的跑马灯效果均使用 <a href=\"https://github.com/selemondev/svelte-marquee\"><code>svelte-marquee</code></a> 组件实现</p>\n<h3>Markdown 渲染</h3>\n<p>使用 <a href=\"https://mdsvex.pngwn.io/\">MDsvex</a> 实现对 md 的渲染</p>\n<h2>部署和性能</h2>\n<p>项目使用 <code>@sveltejs/adapter-static</code> 生成静态网站，通过 GitHub Pages 进行部署。得益于 Svelte 的优秀性能和静态站点生成的特性，网站具有：</p>\n<ul>\n<li>快速的首屏加载</li>\n<li>优秀的 SEO 表现</li>\n<li>简单可靠的部署流程</li>\n</ul>\n<p>如果你对这个项目感兴趣，可以在 <a href=\"https://github.com/QuarkPixel/QuarkPixel.github.io\">GitHub</a> 上查看源代码，项目代码采用 GPLv3 许可证开源。</p>\n",
            "url": "https://quarkpixel.github.io/p/250525-tech-stack-in-hsuans-space",
            "title": "Hsuan's Space 中用到的技术栈",
            "summary": "谈谈本站的开发历程",
            "date_modified": "2025-05-25T00:00:00.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "['Web'",
                "'Develop Diary']"
            ]
        },
        {
            "id": "https://quarkpixel.github.io/p/250523-never-regarded-rust-as-safety",
            "content_html": "<p>每每在社交平台上看到有关 Rust 的内容，「内存安全」和「类型安全」总是如影随形，仿佛这是 Rust 的全部定义。Rust 似乎被贴上了一个光鲜的标签：安全语言。它的官网宣称「丰富的类型系统和所有权模型保证内存安全和线程安全」，社区也乐此不疲地传颂它的可靠性。然而，我从未将 Rust 视为一门「安全」的语言。安全，只是 Rust 独特设计带来的副作用，而非它的核心目标。Rust 的真正魅力，远不止于此。</p>\n<p>在这篇文章中，我将从 Rust 的设计哲学出发，剖析安全特性如何作为副作用自然浮现；探讨为何「安全」标签被官方和社区共同放大；并揭示 Rust 在性能、表达力和灵活性上的多面价值。我希望你能放下对「安全」的刻板印象，重新审视这门语言。</p>\n<h2>安全从何而来？</h2>\n<p>Rust 诞生于 Mozilla，旨在解决 C++ 在系统编程中的痛点：手动内存管理复杂、并发问题难以调试、错误排查耗时。它的核心设计——所有权模型、借用检查器和生命周期——并非为了追求「安全」，而是为了让开发者能够编写可靠、高效的系统级代码。这些机制的细节可以在 <a href=\"https://doc.rust-lang.org/book/\">Rust 官方书籍</a> 中找到，但其核心思想很简单：通过编译时规则，确保内存和并发行为的正确性。</p>\n<p>所有权模型规定，每个值有且仅有一个所有者，值在作用域结束时自动销毁。这消除了 C++ 中手动释放内存的负担，同时避免了悬垂指针和双重释放。借用检查器进一步通过引用规则（不可变借用与可变借用互斥）约束内存访问，防止数据竞争。生命周期则确保引用的有效性，避免引用失效。这些机制共同构成了 Rust 的编译时保障体系，杜绝了空指针、缓冲区溢出等常见错误。</p>\n<p>但这些规则的初衷是什么？不是为了让开发者炫耀「我的代码内存安全」，而是为了解放我们，让我们专注于程序逻辑而非调试内存泄漏或线程死锁。安全，只是这些设计的副作用就。像健康饮食可能带来体重控制，Rust 的设计目标是可靠性和性能，安全是实现这些目标的自然结果。官方虽然强调「内存安全和线程安全」，但更突出「赋予每个人构建可靠且高效软件」的愿景。<strong>安全是手段，而非目的。</strong></p>\n<h2>Unsafe：语法层面的注释</h2>\n<p>如果 Rust 的安全特性是其设计的全部，为何它还提供了 <code>unsafe</code> 关键字？其实这个问题很好回答。毕竟作为一个系统级的编程语言，对底层的可操控性和 Python 一样、或者语法像 C++ 一样灵活好像都不那么合适。因此引入了这样一个「乍看奇怪，实则合理」的产物。</p>\n<p>我对 <code>unsafe</code> 的理解是，它是一种降低开发者心智负担的工具。在非 <code>unsafe</code> 代码中，Rust 的所有权模型和借用检查器充当守门人，自动防止内存泄漏、数据竞争或空指针错误。开发者无需时刻担心变量生命周期或指针合法性，编译器会在错误发生前报错。这种「默认安全」让开发者专注于逻辑而非内存管理。然而，当需要与硬件交互或优化性能时，unsafe 就像一个路标，提醒开发者：「这里要小心。」它要求明确声明责任，划定安全与非安全的边界。</p>\n<p>与 C++ 不同，C++ 要求开发者时刻保持警惕，而 Rust 的 unsafe 将高风险操作隔离到特定代码块，让开发者在大多数时候可以「偷懒」，仅在必要时全神贯注。这种设计平衡了安全与灵活性，体现了 Rust 的实用主义：通过编译时约束最大化可靠性，同时保留系统编程的控制力。unsafe 不是对安全的妥协，而是对开发者的信任，提醒他们在自由与责任间选择。安全，仍是 Rust 优化心智负担的副作用，而非绝对目标。</p>\n<h2>再谈为何「安全」被放大</h2>\n<p>「安全」成为 Rust 的代名词，源于官方的宣传以及社交媒体上越发趋于给一个事物打“标签”。现在的编程语言市场已经趋于饱和，对于新兴语言来说，极力需要一个“卖点”来推销自己。对于官方来说，「安全」就是那个卖点。而对于社交媒体来说，没有一个词可以比「安全」这样一个简洁有力的词来概括一门语言了。因此社交媒体上的这种做法，是极其不负责任的。</p>\n<p>但“安全”标签带来了认知偏差，让 Rust 被简化为“防御性”语言，掩盖其性能和表达力的优势。借用检查器的严格性让新手望而却步，凸显安全并非免费。作为程序员，我们应跳出“安全”这个人云亦云的概念，更加客观、更加全面的去了解一件事物。</p>\n<h2>安全之外</h2>\n<p>如果安全只是副作用，Rust 的真正价值是什么？答案在于它的多面性：性能、表达力和灵活性的完美平衡。</p>\n<p>首先，Rust 的性能接近 C++，得益于其零成本抽象（Zero-Cost Abstractions）。它没有运行时或垃圾回收器，编译器通过优化（如内联、循环展开）确保代码高效运行。这使得 Rust 在高性能场景（如 <a href=\"https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm\">WebAssembly</a>、嵌入式系统）中大放异彩。</p>\n<p>其次，Rust 的类型系统和宏系统提供了强大的表达力。枚举和模式匹配让复杂逻辑更加简洁优雅；<a href=\"https://doc.rust-lang.org/book/ch20-05-macros.html\">声明式宏</a>（<code>macro_rules!</code>）和过程宏支持元编程，极大地减少样板代码。这些特性让 Rust 代码不仅可靠，还充满美感，吸引了追求代码艺术的开发者。</p>\n<p>最后，Rust 的灵活性使其超越了传统系统编程语言的范畴。它支持多种编程范式（函数式、面向对象），适用于从区块链到 AI 的广泛领域。例如，Discord 使用 Rust 优化后端，AWS 的 Firecracker 虚拟化技术也依赖 Rust 的高性能和可靠性。这些案例虽非重点，但足以证明 Rust 的通用性。</p>\n<p>安全只是 Rust 的敲门砖。它的真正魅力在于，它让开发者在性能、可靠性和表达力之间找到平衡。你可以编写接近硬件的低级代码，也可以构建抽象层次高、逻辑清晰的高级系统，而不必被内存管理或并发问题拖累。Rust 不是“安全的 C++”，而是一门重新定义系统编程的语言。</p>\n<h2>重新定义 Rust 的价值</h2>\n<p>Rust 的魅力远不止「安全」二字。它以所有权模型和编译时检查为开发者卸下内存管理的重担，却从不以安全为唯一目标。性能、表达力与灵活性的融合，让 Rust 成为系统编程的新标杆。放下「安全语言」的刻板标签，我们应重新审视 Rust 的初心：赋予开发者自由与掌控力，构建可靠而高效的未来。无论是优化性能的极致追求，还是优雅代码的艺术表达，Rust 都以其独特的设计，邀请我们探索系统编程的无限可能。</p>\n",
            "url": "https://quarkpixel.github.io/p/250523-never-regarded-rust-as-safety",
            "title": "我从未将 Rust 视作一门「安全」的语言",
            "summary": "安全只是它的 Side Effects",
            "date_modified": "2025-05-23T00:00:00.000Z",
            "author": {
                "name": "Xuancong Meng",
                "url": "https://quarkpixel.github.io"
            },
            "tags": [
                "[ 'Rust' ]"
            ]
        }
    ]
}