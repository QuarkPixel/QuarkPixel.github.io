<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Hsuan's Space</title>
        <link>https://quarkpixel.github.io</link>
        <description>Hsuan's personal blog about tech, life, and thoughts</description>
        <lastBuildDate>Wed, 23 Jul 2025 06:07:43 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Feed for Node.js</generator>
        <language>zh-CN</language>
        <image>
            <title>Hsuan's Space</title>
            <url>https://quarkpixel.github.io/logos/large-black.svg</url>
            <link>https://quarkpixel.github.io</link>
        </image>
        <copyright>All rights reserved 2025, Xuancong Meng</copyright>
        <item>
            <title><![CDATA[TextAnimation 的实现细节]]></title>
            <link>https://quarkpixel.github.io/p/250721-details-in-text-animation</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250721-details-in-text-animation</guid>
            <pubDate>Mon, 21 Jul 2025 12:44:11 GMT</pubDate>
            <description><![CDATA[深入解析 svelte-text-animation 组件的技术实现与最新优化]]></description>
            <content:encoded><![CDATA[<p>在<a href="./250525-tech-stack-in-hsuans-space">之前的文章</a>中，我简单提到了自己开发的 <a href="https://github.com/QuarkPixel/svelte-text-animationplaceholder"><code>svelte-text-animation</code></a> 组件。这个组件最初是为了本站首页 Landing 部分的文字动画效果而设计的，后来觉得特别好用就抽象成了一个独立的组件。最近对组件进行了一些优化更新，借此机会来详细介绍一下这个库的实现细节。</p>
<h2>核心设计思路</h2>
<h3>基本原理</h3>
<p>整个动画的核心思想非常简洁：<strong>使用高斯函数叠加边缘递减函数</strong>，为文本中的每个字符计算一个效果强度值，然后通过回调函数将这个强度转换为具体的样式。</p>
<p><img src="https://raw.githubusercontent.com/QuarkPixel/svelte-text-animation/master/assets/example.gif" alt="Demo"></p>
<h3>数学模型</h3>
<p>动画效果由两个关键函数组成：</p>
<ol>
<li><strong>高斯函数</strong>：控制效果在文本中的空间分布</li>
<li><strong>边缘递减函数</strong>：确保动画在起始和结束时平滑过渡</li>
</ol>
<h2>最新优化：更平缓的边缘递减函数</h2>
<h3>原有实现的局限性</h3>
<p>在之前的版本中，边缘递减函数使用的是简单的二次函数：</p>
<p>$$
f_{\text{old}}(p) = 4p(1 - p)
$$</p>
<p>其中 $p$ 表示动画进度（progress）。这个函数确实能够满足边界条件：在 $p = 0$ 和 $p = 1$ 时函数值为 0，在 $p = 0.5$ 时达到最大值 $1$，实现了平滑过渡的目标。</p>
<p>然而，这种实现存在一个显著问题：<strong>动画效果仅在进度接近 0.5 时才能完全展现，其他位置的效果都会被显著削弱</strong>。这意味着动画的大部分时间里，文字效果都无法达到理想状态。</p>
<h3>新的数学方案</h3>
<p>经过深入思考和数学推导，我设计了一个更高阶的多项式函数：</p>
<p>$$
f_{\text{new}}(p) = 1 - (2p - 1)^{2n}
$$</p>
<p>其中 $n$ 对应新增的 <code>edgeFlatness</code> 参数（默认值为 5），用于控制函数的平缓程度。</p>
<p>这个改进后的函数具有以下优秀特性：</p>
<ul>
<li><strong>保持边界条件</strong>：当 $p = 0$ 或 $p = 1$ 时，函数值依然为 $0$</li>
<li><strong>峰值位置不变</strong>：在 $p = 0.5$ 时函数值仍为 $1$</li>
<li><strong>中间区域显著改善</strong>：通过调整 $n$ 参数，可以让更大范围内的进度值都接近最大效果强度</li>
</ul>
<h3>函数特性分析</h3>
<p>通过数学分析可以发现，当 $n = 1$ 时，新函数退化为原有的二次函数。而当 $n &gt; 1$ 时，函数变为 $2n$ 次多项式，相当于在原有基础上增加了一个可调节的平缓度参数。</p>
<center>
<img class="outline outline-[#26796D] outline-3 w-[50%]" src="/assets/20250721-0.gif" alt="edgeFactor 函数演示" />
<em>不同 flatness 值下的边缘递减函数对比</em>
</center>

<p>从图中可以直观看出，随着 <code>flatness</code> 参数的增大，函数在中间区域变得更加平缓，这意味着动画效果在更大的进度范围内都能保持接近最大强度，显著提升了整体的视觉表现。</p>
<h2>核心实现解析</h2>
<h3>效果强度数组生成算法</h3>
<pre><code class="language-typescript">function generateEffectArray(
	length: number,
	progress: number,
	spread: number,
	flatness: number
): number[] {
	// 计算边缘递减因子
	const edgeFactor = 1 - Math.pow(2 * progress - 1, 2 * flatness);
	const result = new Array(length).fill(0);

	// 早期返回优化：当边缘因子为负时直接返回零数组
	if (edgeFactor &lt;= 0) {
		return result;
	}

	// 计算当前动画焦点在文本中的位置
	const offset = progress * (length + 2 * spread + 1) - spread - 1;

	// 优化计算范围，避免不必要的高斯函数计算
	const startIdx = Math.max(0, Math.floor(offset - spread * 3));
	const endIdx = Math.min(length - 1, Math.ceil(offset + spread * 3));

	for (let i = startIdx; i &lt;= endIdx; i++) {
		const z = (i - offset) / spread;
		const zSquared = z * z;

		// 性能优化：当 z² &gt; 9 时，e^(-z²) &lt; 0.01，可以忽略
		if (zSquared &lt; 9) {
			result[i] = Math.exp(-zSquared) * edgeFactor;
		}
	}

	return result;
}
</code></pre>
<h3>关键优化策略</h3>
<ol>
<li><strong>早期返回优化</strong>：当边缘因子小于等于 0 时，直接返回零数组，避免后续无意义的计算</li>
<li><strong>智能范围限制</strong>：仅对可能产生显著效果的字符范围进行计算，大幅降低计算复杂度</li>
<li><strong>高斯函数截断</strong>：利用指数函数的快速衰减特性，当距离过远时直接跳过计算</li>
</ol>
<h2>API 设计</h2>
<h3>核心参数接口</h3>
<pre><code class="language-typescript">interface Props {
	text: string;                                 // 要进行动画的文本内容
	progress: number;                             // 动画进度，取值范围 [0, 1]
	spread?: number;                              // 效果扩散半径，默认 3
	edgeFlatness?: number;                        // 边缘平缓度，默认 5
	styleCallback: (intensity: number) =&gt; string; // 强度到样式的转换函数
	innerClassName?: string;                      // 字符容器的 CSS 类名
}
</code></pre>
<h3>实际使用示例</h3>
<pre><code class="language-svelte">&lt;TextAnimation
    text=&quot;Hello, World!&quot;
    {progress}
    spread={4}
    edgeFlatness={6}
    styleCallback={(intensity) =&gt; `
        transform: scale(${1 + intensity * 0.5});
        color: rgb(${255}, ${Math.floor(255 * intensity)}, ${Math.floor(255 * intensity)});
    `}
/&gt;
</code></pre>
<p>你可以在 <a href="https://svelte.dev/playground/434018293cfb415b925f19b47ef4a85c?version=5.33.1">Svelte Playground</a> 中直接体验这个组件的效果。</p>
<p>实际应用场景可以参考本博客首页的 Landing 部分，对应的源码实现：<a href="https://github.com/QuarkPixel/QuarkPixel.github.io/blob/master/src/routes/Landing.svelte">Landing.svelte</a>。</p>
<hr>
<h2>总结</h2>
<p><code>svelte-text-animation</code> 通过精心设计的数学函数组合，实现了既平滑又视觉效果出色的文字动画。最新版本中边缘递减函数的优化，通过引入可调节的平缓度参数，显著提升了动画在整个进度范围内的表现效果。</p>
<p>这种基于数学模型的设计方法不仅保证了动画的流畅性，还为开发者提供了充分的自定义空间。如果你对这个组件感兴趣，欢迎在 <a href="https://github.com/QuarkPixel/svelte-text-animation">GitHub</a> 上为项目点个 Star 😆</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>['Technique'</category>
            <category>'Web']</category>
        </item>
        <item>
            <title><![CDATA[HDR 在被滥用吗]]></title>
            <link>https://quarkpixel.github.io/p/250720-is-hdr-being-overused</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250720-is-hdr-being-overused</guid>
            <pubDate>Sun, 20 Jul 2025 11:24:30 GMT</pubDate>
            <description><![CDATA[谈谈现今 HDR 的一些问题]]></description>
            <content:encoded><![CDATA[<script>
import BiliPlayer from '$lib/components/BiliPlayer.svelte';
</script>

<p><strong>这是一篇讨论帖，由于本人没有实际上手过新的操作系统，故所有内容均来自网络，内容可能有误。欢迎发表自己的看法～</strong></p>
<h2>引言</h2>
<p>起因来自一条视频，展示了 Apple 在新系统的画笔中支持选择 <a href="https://en.wikipedia.org/wiki/High_dynamic_range">HDR</a> 颜色。</p>
<BiliPlayer bv="BV1TW33zdE2T" />

<p>给我的第一感受就是：<strong>怪</strong>。</p>
<p>我其实能理解为什么 Apple 会允许选择 HDR 颜色，让系统整体对 HDR 有更深度的融合。但我不禁要问：这样的 HDR 真的合理吗？设计生态真的准备好了吗？</p>
<p>我的担心是：HDR 技术为 UI 带来了更丰富的视觉表现力，但在缺乏统一设计语言和生态支持的前提下，Apple 等厂商的 &quot;开放式 HDR
策略&quot; 反而可能破坏用户界面的一致性，增加设计负担。</p>
<h2>HDR 的潜力</h2>
<p>HDR 如果处理得好的话，UI 确实可以美到飞起。</p>
<p>HDR 不只是让画面更亮、更艳，更重要的是它为界面设计引入了 &quot;亮度空间&quot; 这一新的表达维度。从传统的颜色/对比度控制，拓展到了真实光强的建构。得益于此，HDR
可作为界面结构化、分层与焦点引导的新工具。例如：</p>
<ul>
<li><p>通过局部高亮引导用户注意力，而非依赖颜色或动画；</p>
</li>
<li><p>模拟真实光源制造视觉层次感，从而增强沉浸体验；</p>
</li>
<li><p>赋予 UI 元素不同的“光学存在感”，区分主次关系。</p>
</li>
</ul>
<p>这些观点指向一个共识：<strong>HDR 是视觉强化的强力工具，但前提是 &quot;设计得好&quot; ，且配合统一的设计语言与生态标准。</strong> 否则，它也可能成为破坏体验的利器。</p>
<h2>问题在于 HDR 没有统一标准</h2>
<p>但现实情况是，我们的 HDR UI 体验远没有达到理想状态。</p>
<h3>系统层面的设计不一致</h3>
<p>最明显的问题是视觉连贯性的缺失。我们经常能看到 HDR 视频在普通 UI 界面上播放，导致整体界面看起来发灰、不协调。这种 &quot;接缝感&quot;
破坏了用户界面应有的统一性。</p>
<p>还有 Reddit
用户提到 <a href="https://www.reddit.com/r/appletv/comments/x2al6l/youtube_adverts_causing_huge_delay_because_tv/">YouTube 广告因 HDR 切换导致画面延迟和色彩跳变</a>
，严重影响观看体验。</p>
<p>这些问题的根源在于：<strong>HDR 在系统 UI 中的体验不连贯，打断了用户的视觉流，这是设计上的失败。</strong></p>
<h3>缺乏设计指导下的 &quot;自由发挥&quot;</h3>
<p>当技术门槛降低，HDR 变得人人可用时，缺乏设计规范的约束就会带来问题。</p>
<p>我们确实看到了一些令人担忧的现象：抖音上有用户开始使用带有HDR高亮的表情包进行恶搞，这些内容因为比平常的图片更亮而获得关注。</p>
<details>
  <summary>[视频] 这年头，表情包都自带HDR了？</summary>
  <BiliPlayer bv="BV1HkTuzcE7V" />
</details>

<p>类似的情况还出现在广告投放中，HDR被用作粗暴的注意力抓取工具，而不是精心设计的视觉体验。这些现象本身不是核心问题，而是设计缺位的副作用。</p>
<details>
  <summary>[视频] 野生的网页 HDR 广告</summary>
  <BiliPlayer bv="BV1sw4m1d7L1" />
</details>


<p><strong>HDR UI 当前的问题不是 HDR 本身，而是没有明确的 &quot;设计语言&quot; 和规范来驾驭它。</strong></p>
<h3>生态支持的不成熟</h3>
<p>更深层的问题在于，我们的数字生态还没有准备好迎接 &quot;全面HDR化&quot;。</p>
<p>第三方应用、浏览器、视频播放器对 HDR 的支持参差不齐，导致用户在不同场景下体验到的 HDR 效果千差万别。有时候 HDR
让界面更加精致，有时候又让整体显得突兀。这种不可预测性正是设计大忌。</p>
<p>Steam 社区论坛上有用户抱怨 <a href="https://steamcommunity.com/discussions/forum/11/7074686901648727412/">HDR 显示器效果的糟糕</a>
，虽然不知道具体的原因，但我们可以明确的是现在的 HDR 领域无比混乱。</p>
<h2>结语</h2>
<p>回到开头的问题：Apple 开放 HDR 究竟是好事还是坏事？</p>
<p>我的观点是：<strong>HDR是好工具，但应该被认真对待。</strong></p>
<p>我们需要的不是 HDR 的全面开放，而是有设计指导的 HDR 应用。Apple 等厂商在推广 HDR 技术时，应该投入更多精力建立统一的设计规范和使用标准；软件厂商在对接
HDR 技术时，也更应该谨慎对待。</p>
<h2>参考文章</h2>
<ul>
<li><a href="https://medium.com/design-bootcamp/what-hdr-in-ui-tells-us-about-the-future-of-digital-perception-bb3d9133d1f6">HDR in UI: Designing Perception Through
Brightness</a></li>
<li><a href="https://medium.com/design-bootcamp/the-rise-of-hdr-ui-not-a-visual-gimmick-but-a-paradigm-shift-in-perceptual-logic-8062247f72dd">HDR UI and EDR: Rethinking Brightness in Interface Design</a></li>
<li><a href="https://medium.com/design-bootcamp/is-your-ui-design-file-still-representing-the-final-output-in-the-hdr-ui-era-4bd4fb1f4b9d">Is Your UI Design File Still Representing the Final Output in the HDR UI Era?</a></li>
</ul>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Thinking'</category>
            <category>'Visual' ]</category>
        </item>
        <item>
            <title><![CDATA[夏长，云懒。]]></title>
            <link>https://quarkpixel.github.io/p/250712-summer-clouds</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250712-summer-clouds</guid>
            <pubDate>Sat, 12 Jul 2025 07:15:00 GMT</pubDate>
            <description><![CDATA[记录平时拍摄的云]]></description>
            <content:encoded><![CDATA[<p><strong>夏日的云，也想慵懒。</strong></p>
<p>平时喜欢去天台散心：没有喧嚣，只有自己。夏日的云和其它时候都不一样。从专业术语的角度出发，我爱看夏天的<a href="https://zh.wikipedia.org/wiki/%E7%A7%AF%E4%BA%91">积云</a>。记这些年来拍到的夏日云：</p>
<div class="bg-surface-100-900 outline-9 rounded-xl my-2 outline-surface-100-900 grid grid-cols-3 grid-rows-6 gap-2 [&_img]:w-full [&_img]:h-full [&_img]:object-cover [&_img]:m-0 *>rounded-xl *>shadow-lg *>overflow-hidden *>bg-gray-200">
  <div class="col-start-1 col-span-2 row-start-1 row-span-2">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332223628-62631dabb337"/>
  </div>
  
  <div class="col-start-3 col-span-1 row-start-1 row-span-3">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332223533-993114881882"/>
  </div>
  
  <div class="col-start-1 col-span-1 row-start-3 row-span-3">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332223583-0d94cb2911f7"/>
  </div>
  
  <div class="col-start-2 col-span-2 row-start-4 row-span-1">
    <img alt="clouds" src="https://images.unsplash.com/photo-1695450148576-675cab2c9215"/>
  </div>
  
  <div class="col-start-2 col-span-1 row-start-3 row-span-1">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332223520-1278796028f5"/>
  </div>
  
  <div class="col-start-3 col-span-1 row-start-5 row-span-2">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332222129-6e44eb7e3f29"/>
  </div>
  
  <div class="col-start-2 col-span-1 row-start-5 row-span-2">
    <img alt="clouds" src="https://images.unsplash.com/photo-1727843062665-040b10410226"/>
  </div>
  
  <div class="col-start-1 col-span-1 row-start-6 row-span-1">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332223050-253b7b199a68"/>
  </div>
</div>
<div class="-mt-1"><a class="text-surface-400-600 font-noto-sans text-sm" href="https://unsplash.com/@quarkpixel">Unsplash @quarkpixel</a></div>

]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Photography' ]</category>
        </item>
        <item>
            <title><![CDATA[重做网页布局排版]]></title>
            <link>https://quarkpixel.github.io/p/250701-remake-typography</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250701-remake-typography</guid>
            <pubDate>Tue, 01 Jul 2025 07:15:00 GMT</pubDate>
            <description><![CDATA[从 Skeleton 转向 Tailwind Typography]]></description>
            <content:encoded><![CDATA[<p>许久之前就无法忍受网页的排版。作为一个博客网站，文字的呈现效果是至关重要的。在之前介绍<a href="./250525-tech-stack-in-hsuans-space">网站使用的技术栈</a>时就提到我使用了 Skeleton 作为 UI 框架。然而这个框架在排版方面的表现很不尽如人意。我趁着最近在大量升级网站的机会，将排版系统从 Skeleton + MDsveX 自定义样式转向了 Tailwind Typography + MDsveX 默认对接。</p>
<center>
<img class="outline outline-[#808CA9] outline-4 rounded-[1px] mb-[44px]" src="/assets/20250701-0.webp" alt="" />
<em>左图：新版｜右图：老版</em>
</center>

<h2>使用 Skeleton 所遇到的问题</h2>
<p><a href="https://skeleton.dev/">Skeleton</a> 是一个非常优秀的 UI 框架，它为 SvelteKit 提供了美观且功能丰富的组件库。在构建网站的导航栏、按钮、卡片等常规 UI 组件时，Skeleton 的表现令人满意。</p>
<p>然而，当面对大量文字排版这样的特定场景时，Skeleton 就不再能胜任。它更着重于 UI，而非排版。在此之前我因为偷懒，就没有想着用专业的排版引擎 😂</p>
<p>此外，即使作为一个 UI 组件集，我认为 Skeleton 在排版方面也远不算合格。它不基于语义化标签作用样式，甚至还将语义化标签的样式都重置了。因此当你直接使用 <code>&lt;h1&gt;</code> 时，它是没有任何样式的。这是因为 Skeleton 要求你为每个标题添加对应的 class：</p>
<pre><code class="language-html">&lt;!-- 没有样式，因为缺少 class --&gt;
&lt;h1&gt;Hello World&lt;/h1&gt;

&lt;!-- “正确” 的使用方式，但很难评 --&gt;
&lt;h1 class=&quot;h1&quot;&gt;Hello World&lt;/h1&gt;
</code></pre>
<p>而这在与 MDsveX 对接时就产生了问题：MDsveX 只生成纯 HTML 结构，这在与 Skeleton 的对接中就出现了问题。因此我不得不为每一个基本元素都写一个包装组件：</p>
<pre><code class="language-bash">➜ HsuansSpace/src/lib/components/typography master ✓ tree .     
.
├── Anchor.svelte
├── BaseList.svelte
├── Blockquote.svelte
├── Code.svelte
├── Del.svelte
├── H1.svelte
├── H2.svelte
├── H3.svelte
├── H4.svelte
├── H5.svelte
├── H6.svelte
├── Hr.svelte
├── Image.svelte
├── Ins.svelte
├── Italic.svelte
├── Keyboard.svelte
├── Mark.svelte
├── OrderedList.svelte
├── P.svelte
├── Pre.svelte
├── Table.svelte
├── TableBody.svelte
├── UnorderedList.svelte
└── index.ts

1 directory, 24 files
</code></pre>
<p>抛去麻烦的问题外，还有一些样式的不兼容等问题就在这样一层又一层的屎山中构建起来了。</p>
<h2>转换为 Tailwind Typography</h2>
<p><a href="https://tailwindcss.com/docs/typography-plugin">Tailwind Typography</a> 是一个官方专门为文章排版设计的插件。它提供了：</p>
<ul>
<li>精心调教的文字间距和行高</li>
<li>优雅的标题层级样式</li>
<li>完善的列表和引用样式</li>
<li>适配不同屏幕尺寸的响应式排版</li>
</ul>
<p>最重要的是，Tailwind Typography 完全基于语义化标签工作，与 MDsveX 的默认渲染完美契合。这意味着我们可以专注于写作内容，不必再为每个 HTML 标签编写包装组件，因为屎山堆叠所导致的样式错误问题也消失了。</p>
<h2>迁移过程</h2>
<p>迁移过程出乎意料地顺利。主要步骤包括：</p>
<ol>
<li>移除 Skeleton 中的文章样式覆盖</li>
<li>配置 Tailwind Typography 插件</li>
<li>为文章容器添加 <code>prose</code> 类</li>
<li>调整默认颜色配置，使其适配 Skeleton 的颜色系统</li>
</ol>
<h2>总结</h2>
<p>有时候，简单的解决方案反而是最好的。Tailwind Typography 专注于解决文章排版这一具体问题，而不是试图成为一个全能的框架。这让它在这个特定场景下的表现远超 Skeleton。</p>
<p>你可以在这里查看完整的 <a href="/test">Markdown 语法测试</a>，体验新的排版效果。</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Develop Diary' ]</category>
        </item>
        <item>
            <title><![CDATA[支持 RSS 订阅啦！]]></title>
            <link>https://quarkpixel.github.io/p/250629-new-rss-feature</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250629-new-rss-feature</guid>
            <pubDate>Sun, 29 Jun 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[添加 RSS Feed 支持，以及其他方面的网站改进]]></description>
            <content:encoded><![CDATA[<p>为博客添加了 RSS 订阅功能！🎉</p>
<p>现在你可以通过 RSS 阅读器订阅本博客的更新了。支持以下几种订阅格式：</p>
<ul>
<li><a href="/feed/rss.xml">RSS 2.0</a></li>
<li><a href="/feed/atom.xml">Atom</a></li>
<li><a href="/feed/feed.json">JSON Feed</a></li>
</ul>
<p>RSS（Really Simple Syndication）是一种很棒的信息获取方式。通过 RSS，你可以在自己喜欢的阅读器中统一管理和阅读订阅的内容，不会错过任何更新，也不用担心算法推荐的干扰。</p>
<p>此外，网站更新的内容还有：</p>
<ul>
<li>Footer 的重置***（新版本的效果我很满意😁）***</li>
<li>友链支持</li>
<li>网站后台监控***（使用 <a href="https://umami.is">Umami</a> 服务）***以及更新 <a href="/privacy">隐私政策</a></li>
<li>首页 Landing 现在可以鼠标交互了✨</li>
</ul>
<p>欢迎订阅本博客的 RSS feed！📮</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Develop Diary' ]</category>
        </item>
        <item>
            <title><![CDATA[Rust 是一门适合 Vibe Coding 的语言]]></title>
            <link>https://quarkpixel.github.io/p/250623-rust-is-suitable-for-vibe-coding</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250623-rust-is-suitable-for-vibe-coding</guid>
            <pubDate>Mon, 23 Jun 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[从安全特性、错误提示和自动化验证的角度，探讨为什么 Rust 可能是最适合 AI 编程的语言]]></description>
            <content:encoded><![CDATA[<p><strong>以下内容纯属个人观点，权当暴论一则。</strong></p>
<p><a href="https://en.wikipedia.org/wiki/Vibe_coding">Vibe Coding</a> 是一种依赖 AI 快速生成代码并通过直觉调整的编程范式，特别适合快速原型开发、黑客马拉松等需要快速验证想法的场景。在这样的编程模式下，我认为 Rust 是一门非常适合的编程语言。</p>
<h2>Rust 与 AI 的完美契合</h2>
<p>Rust 的安全特性恰好弥补了 AI 生成代码时的 “先天不足”。在 Vibe Coding 中，最大的风险就是 AI 可能生成包含不可预知 bug 的代码。而 Rust 的编译器能在编译阶段就捕获大多数潜在问题，不论是边界条件的忽略，还是其他隐藏的安全隐患。</p>
<p>经常有人说 “Rust 是给编程菜鸟用的，只有菜鸟才需要这些规则来约束保证安全。高手都用 C 语言这样自由的语言。” 不论这个观点本身是否正确，但 “Rust 更适合容易出错的编程者” 这一点确实是客观存在的。而在 Vibe Coding 的场景下，AI 恰恰就是这样一个 “需要被约束的菜鸟”。</p>
<h2>错误提示系统的革新价值</h2>
<p>Rust 完善的错误提示系统，其最大的优势在于对 AI 的友好性。详细的错误信息使得 AI 能够更准确地理解问题所在，并进行精确的代码修正。这种特性让 AI 能够自主完成大部分代码优化工作，人类开发者只需要在最后环节进行把关。</p>
<h2>自动化验证的突破</h2>
<p>目前的 Vibe Coding 范式中，代码验证和检查主要依赖人工完成。这在软件工程的角度来看是不合理的——能交给机器完成的工作，就不应该依赖人工。Rust 的编译器恰好可以扮演这个自动化验证工具的角色，让我们真正实现&quot;机器生成，机器验证&quot;的理想状态。</p>
<h2>当前的局限性</h2>
<p>尽管 Rust 在理论上非常适合 Vibe Coding，但目前它还没有成为这一领域的主流选择。这主要是因为像 Python、JavaScript 这样的语言拥有更丰富的代码语料库、更多的教程资源和更完善的生态系统，这些都是训练 AI 模型所必需的基础设施。相比之下，Rust 生态虽然在快速发展，但在资源丰富程度上还有一定差距。不过，随着 Rust 社区的不断壮大和应用场景的拓展，这个差距正在逐步缩小。</p>
<h2>结论</h2>
<p>Rust 不仅仅是一个适合 Vibe Coding 的语言，它通过独特的安全特性、友好的错误提示和强大的编译器验证，从根本上解决了 AI 编程中的核心问题。尽管目前在资源上还有一定局限，但 Rust 在 Vibe Coding 领域展现出的潜力是不容忽视的。</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Rust'</category>
            <category>'AI']</category>
        </item>
        <item>
            <title><![CDATA[上线评论功能～]]></title>
            <link>https://quarkpixel.github.io/p/250616-new-giscus-module</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250616-new-giscus-module</guid>
            <pubDate>Mon, 16 Jun 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[添加基于 Giscus 的评论系统]]></description>
            <content:encoded><![CDATA[<p>终于给博客加上了评论功能！🎉</p>
<p>选用了 <a href="https://giscus.app/">giscus</a> 作为评论系统，它基于 GitHub Discussions，完全开源且免费。最重要的是，它支持 Markdown 语法，可以让我们能更好地交流想法。</p>
<p>现在，你可以在每篇文章的底部看到评论区了。欢迎来聊聊天呀～</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Develop Diary' ]</category>
        </item>
        <item>
            <title><![CDATA[也许我们早已在电车难题中做出了选择？]]></title>
            <link>https://quarkpixel.github.io/p/250609-the-trolley-problem-and-suicide</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250609-the-trolley-problem-and-suicide</guid>
            <pubDate>Mon, 09 Jun 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[聊聊阻止自杀与电车难题]]></description>
            <content:encoded><![CDATA[<p>最近我在思考一个问题：电车难题的选择与阻止自杀的抉择是否有着相似的本质？</p>
<p>最初的思考源于一个假设：</p>
<blockquote>
<p>假设世界有这样一条设定***（尽管价值观未必正确，但有助于讨论）<em><strong>：存在天堂，只有通过自杀</strong></em>（主观选择死亡）***的人因其“勇敢”而获得更好的待遇，而非自主死亡的人则命运平庸。<br>在此设定下，一个人选择自杀，另一人阻止他，是否正确？</p>
</blockquote>
<p>这看似荒谬，但换个角度：<strong>选择自杀的人往往因极度痛苦而寻求解脱</strong>。自杀对他们而言，如同进入“天堂”或摆脱苦难。从这点看，自杀的动机与“天堂假设”殊途同归：主体都追求更好的结果。但前提是，若自杀未遂，生活未改善，痛苦依旧。</p>
<p>关键问题是：若救下自杀者却无法善待他，阻止自杀是否成了错误？</p>
<hr>
<h3>我们可以将此与<strong>电车难题</strong>类比：</h3>
<ul>
<li><em><em>一人</em>（自杀者）</em><strong>：若不拉杆</strong><em>（不阻止自杀）</em><strong>，他得以“解脱”</strong><em>（如同进入天堂或摆脱痛苦）</em>**。</li>
<li><em><em>五人</em>（在意他的人）</em>**：泛指任何得知自杀后会伤心的人，如亲友。</li>
<li><strong>抉择</strong>：拉杆***（阻止自杀）<em><strong>亦或 不拉杆</strong></em>（放任自杀）***。</li>
</ul>
<h3>由此，问题转化为：</h3>
<ul>
<li><strong>不拉杆</strong>：自杀者解脱，但在意他的人因失去他而痛苦。</li>
<li><strong>拉杆</strong>：自杀者被救下，若未被善待，则继续痛苦；在意他的人免于悲伤。</li>
</ul>
<p>阻止自杀的人做错了吗？我的答案是：没有。他只是做出了电车难题中的选择，权衡了个体解脱与他人的情感损失。同样，若有人选择不阻止自杀，也不应苛责，因为这也是基于个人价值观的决定。</p>
<p>那么，对于电车难题中的拉杆抉择，我们是否早已在生活中做出了选择？在“被救者未被善待”的前提下，阻止自杀可能让痛苦延续，类似电车难题中牺牲一人救多数的道德困境。然而，若救下的人能被善待，痛苦得以缓解，这场抉择的意义便截然不同。</p>
<h4>结尾</h4>
<p>或许，电车难题与阻止自杀的共通之处在于：我们都在有限的信息与复杂的道德权重中挣扎。拉杆与否，没有绝对的正误，关键在于后续的善待能否实现。如果我们能确保救下的灵魂被温柔以待，电车难题的拉杆，或许早已有了答案。否则，我们的选择可能只是将痛苦从一方移到另一方，永远在伦理的灰色地带徘徊。</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Thinking'</category>
            <category>]</category>
        </item>
        <item>
            <title><![CDATA[Hsuan's Space 中用到的技术栈]]></title>
            <link>https://quarkpixel.github.io/p/250525-tech-stack-in-hsuans-space</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250525-tech-stack-in-hsuans-space</guid>
            <pubDate>Sun, 25 May 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[谈谈本站的开发历程]]></description>
            <content:encoded><![CDATA[<p>关于「我要做一个关于自己的网页」这个 Flag 我已经立了若干年了，最近这段时间终于有动力来完成它。尝试了没有接触过的技术，花了近半个月的时间，完成了网页的搭建。</p>
<p><img src="https://wakatime.com/badge/user/018b19a3-343c-48f6-8ba9-5713e3a014cc/project/e4f1a103-1fe2-4a7b-afe8-35b4df2164b6.svg?style=flat-square" alt="Wakatime badage">
<em>Time in this web project over all time</em></p>
<p>本站采用了现代化的 Web 开发技术栈，主要包括：SvelteKit、TailwindCSS、MDsveX 和 Skeleton UI.</p>
<h2>1. 字体</h2>
<p>正文部分使用 <a href="https://github.com/lxgw/LxgwWenKai">霞鹜文楷</a>。</p>
<h4>其余字体</h4>
<ul>
<li>Noto Serif SC Variable</li>
<li>Noto Sans SC Variable</li>
<li>Caveat Variable</li>
<li>Gravitas One</li>
</ul>
<p>值得注意的是，本网站使用了<a href="https://chinese-font.netlify.app/zh-cn/online-split/">字体分包</a>技术，由<a href="https://chinese-font.netlify.app/zh-cn/">中文网字计划</a>支持。因此在初次访问网站时，字体会有很独特的加载顺序。</p>
<h2>2. 动画</h2>
<h3>可变字体动画</h3>
<p>使用自己做的另外一款组件<a href="https://github.com/QuarkPixel/svelte-text-animation"><code>svelte-text-animation</code></a>，这款组件的开发是在网页的开发过程中想到的灵感，就花了差不多一个下午的时间来实现。整体效果还是很惊艳的，用在了首页 Landing
的部分 😆。</p>
<p>具体实现的细节其实很是很简单的，使用一个高斯函数叠加上一个边缘递减函数，就可以实现一个平滑的动画效果。</p>
<h3>Logo 动画</h3>
<p>我尝试了市面上很多的 SVG 动画库，但是要么就是太过臃肿，要么就是实现的效果很奇怪，没法做到我要求的“点对点移动”的效果。于是我心一狠，直接手撕了一个SVG动画引擎。其实实际实现起来，没有想象的那么复杂。这也多亏了
Svelte 大量的内置函数，使用起来体验很不错。</p>
<script>
    import Logo from '$lib/components/Logo.svelte';
    import { bounceOut, elasticOut } from 'svelte/easing'; 
	let logoOfficial = true;
</script>

<p>&lt;button 
    class=&quot;mt-20 mb-3 w-full flex justify-around gap-10 *:h-30 *:w-40&quot;
    onmouseenter={() =&gt; logoOfficial = false}
    onmouseleave={() =&gt; logoOfficial = true}</p>
<blockquote>
</blockquote>
<pre><code>&lt;Logo
    official={logoOfficial}
    easing={elasticOut}
/&gt;
&lt;Logo
    official={logoOfficial}
/&gt;
&lt;Logo
    official={logoOfficial}
    easing={bounceOut}
/&gt;
</code></pre>
</button>
<div align="center" class="mb-15 opacity-65 font-gravitas-one">↑ Hover Me ↑</div>

<h4>核心代码：</h4>
<pre><code class="language-typescript">// Derive interpolated path coordinates
let interpolatedPaths: Shape[] = $derived(
	paths.map(path =&gt;
		path.initial.map((start, i) =&gt; {
			const end = path.target[i];
			const x = start[0] + (end[0] - start[0]) * path.tween.current;
			const y = start[1] + (end[1] - start[1]) * path.tween.current;
			return [x, y];
		})
	)
);

// Derive SVG path d attributes
let dValues: string[] = $derived(
	interpolatedPaths.map(points =&gt;
		`M${points.map((point) =&gt; point.join(&#39; &#39;)).join(&#39;L&#39;)}Z`
	)
);
</code></pre>
<h3>Header 的背景噪声图</h3>
<p>具体实现是使用一张噪声纹理图</p>
<center>
<p>
    <img src="/noise-texture.png" alt>
    <em>噪声纹理图</em>
</p>
</center>

<h5>但由于不同屏幕尺寸可能会导致纹理图发糊。因此我做了这些工作：</h5>
<ul>
<li>添加属性 <code>image-rendering: pixelated;</code>，具体属性说明参见<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering">MDN</a></li>
<li>动态计算图片展示大小，使得图片可以1:1像素展示在显示器上：</li>
</ul>
<pre><code class="language-typescript">function calcNoiseSize() {
	const dpr = window.devicePixelRatio || 1;
	noiseTextureSize = NOISE_TEXTURE_SIZE / dpr;
}

if (browser) {
	calcNoiseSize();
}

onMount(() =&gt; {
	window.addEventListener(&#39;resize&#39;, calcNoiseSize);

	return () =&gt; window.removeEventListener(&#39;resize&#39;, calcNoiseSize);
});
</code></pre>
<h3>Marquee</h3>
<p>页面内所有的跑马灯效果均使用 <a href="https://github.com/selemondev/svelte-marquee"><code>svelte-marquee</code></a> 组件实现</p>
<h3>Markdown 渲染</h3>
<p>使用 <a href="https://mdsvex.pngwn.io/">MDsvex</a> 实现对 md 的渲染</p>
<h2>部署和性能</h2>
<p>项目使用 <code>@sveltejs/adapter-static</code> 生成静态网站，通过 GitHub Pages 进行部署。得益于 Svelte 的优秀性能和静态站点生成的特性，网站具有：</p>
<ul>
<li>快速的首屏加载</li>
<li>优秀的 SEO 表现</li>
<li>简单可靠的部署流程</li>
</ul>
<h5>如果你对这个项目感兴趣，可以在 <a href="https://github.com/QuarkPixel/QuarkPixel.github.io">GitHub</a> 上查看源代码，项目代码采用 GPLv3 许可证开源。</h5>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Web'</category>
            <category>'Develop Diary' ]</category>
        </item>
        <item>
            <title><![CDATA[我从未将 Rust 视作一门「安全」的语言]]></title>
            <link>https://quarkpixel.github.io/p/250523-never-regarded-rust-as-safety</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250523-never-regarded-rust-as-safety</guid>
            <pubDate>Fri, 23 May 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[安全只是它的 Side Effects]]></description>
            <content:encoded><![CDATA[<p>每每在社交平台上看到有关 Rust 的内容，「内存安全」和「类型安全」总是如影随形，仿佛这是 Rust 的全部定义。Rust 似乎被贴上了一个光鲜的标签：安全语言。它的官网宣称「丰富的类型系统和所有权模型保证内存安全和线程安全」，社区也乐此不疲地传颂它的可靠性。然而，我从未将 Rust 视为一门「安全」的语言。安全，只是 Rust 独特设计带来的副作用，而非它的核心目标。Rust 的真正魅力，远不止于此。</p>
<p>在这篇文章中，我将从 Rust 的设计哲学出发，剖析安全特性如何作为副作用自然浮现；探讨为何「安全」标签被官方和社区共同放大；并揭示 Rust 在性能、表达力和灵活性上的多面价值。我希望你能放下对「安全」的刻板印象，重新审视这门语言。</p>
<h2>安全从何而来？</h2>
<p>Rust 诞生于 Mozilla，旨在解决 C++ 在系统编程中的痛点：手动内存管理复杂、并发问题难以调试、错误排查耗时。它的核心设计——所有权模型、借用检查器和生命周期——并非为了追求「安全」，而是为了让开发者能够编写可靠、高效的系统级代码。这些机制的细节可以在 <a href="https://doc.rust-lang.org/book/">Rust 官方书籍</a> 中找到，但其核心思想很简单：通过编译时规则，确保内存和并发行为的正确性。</p>
<p>所有权模型规定，每个值有且仅有一个所有者，值在作用域结束时自动销毁。这消除了 C++ 中手动释放内存的负担，同时避免了悬垂指针和双重释放。借用检查器进一步通过引用规则（不可变借用与可变借用互斥）约束内存访问，防止数据竞争。生命周期则确保引用的有效性，避免引用失效。这些机制共同构成了 Rust 的编译时保障体系，杜绝了空指针、缓冲区溢出等常见错误。</p>
<p>但这些规则的初衷是什么？不是为了让开发者炫耀「我的代码内存安全」，而是为了解放我们，让我们专注于程序逻辑而非调试内存泄漏或线程死锁。安全，只是这些设计的副作用就。像健康饮食可能带来体重控制，Rust 的设计目标是可靠性和性能，安全是实现这些目标的自然结果。官方虽然强调「内存安全和线程安全」，但更突出「赋予每个人构建可靠且高效软件」的愿景。<strong>安全是手段，而非目的。</strong></p>
<h2>Unsafe：语法层面的注释</h2>
<p>如果 Rust 的安全特性是其设计的全部，为何它还提供了 <code>unsafe</code> 关键字？其实这个问题很好回答。毕竟作为一个系统级的编程语言，对底层的可操控性和 Python 一样、或者语法像 C++ 一样灵活好像都不那么合适。因此引入了这样一个「乍看奇怪，实则合理」的产物。</p>
<p>我对 <code>unsafe</code> 的理解是，它是一种降低开发者心智负担的工具。在非 <code>unsafe</code> 代码中，Rust 的所有权模型和借用检查器充当守门人，自动防止内存泄漏、数据竞争或空指针错误。开发者无需时刻担心变量生命周期或指针合法性，编译器会在错误发生前报错。这种「默认安全」让开发者专注于逻辑而非内存管理。然而，当需要与硬件交互或优化性能时，unsafe 就像一个路标，提醒开发者：「这里要小心。」它要求明确声明责任，划定安全与非安全的边界。</p>
<p>与 C++ 不同，C++ 要求开发者时刻保持警惕，而 Rust 的 unsafe 将高风险操作隔离到特定代码块，让开发者在大多数时候可以「偷懒」，仅在必要时全神贯注。这种设计平衡了安全与灵活性，体现了 Rust 的实用主义：通过编译时约束最大化可靠性，同时保留系统编程的控制力。unsafe 不是对安全的妥协，而是对开发者的信任，提醒他们在自由与责任间选择。安全，仍是 Rust 优化心智负担的副作用，而非绝对目标。</p>
<h2>再谈为何「安全」被放大</h2>
<p>「安全」成为 Rust 的代名词，源于官方的宣传以及社交媒体上越发趋于给一个事物打“标签”。现在的编程语言市场已经趋于饱和，对于新兴语言来说，极力需要一个“卖点”来推销自己。对于官方来说，「安全」就是那个卖点。而对于社交媒体来说，没有一个词可以比「安全」这样一个简洁有力的词来概括一门语言了。因此社交媒体上的这种做法，是极其不负责任的。</p>
<p>但“安全”标签带来了认知偏差，让 Rust 被简化为“防御性”语言，掩盖其性能和表达力的优势。借用检查器的严格性让新手望而却步，凸显安全并非免费。作为程序员，我们应跳出“安全”这个人云亦云的概念，更加客观、更加全面的去了解一件事物。</p>
<h2>安全之外</h2>
<p>如果安全只是副作用，Rust 的真正价值是什么？答案在于它的多面性：性能、表达力和灵活性的完美平衡。</p>
<p>首先，Rust 的性能接近 C++，得益于其零成本抽象（Zero-Cost Abstractions）。它没有运行时或垃圾回收器，编译器通过优化（如内联、循环展开）确保代码高效运行。这使得 Rust 在高性能场景（如 <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm">WebAssembly</a>、嵌入式系统）中大放异彩。</p>
<p>其次，Rust 的类型系统和宏系统提供了强大的表达力。枚举和模式匹配让复杂逻辑更加简洁优雅；<a href="https://doc.rust-lang.org/book/ch20-05-macros.html">声明式宏</a>（<code>macro_rules!</code>）和过程宏支持元编程，极大地减少样板代码。这些特性让 Rust 代码不仅可靠，还充满美感，吸引了追求代码艺术的开发者。</p>
<p>最后，Rust 的灵活性使其超越了传统系统编程语言的范畴。它支持多种编程范式（函数式、面向对象），适用于从区块链到 AI 的广泛领域。例如，Discord 使用 Rust 优化后端，AWS 的 Firecracker 虚拟化技术也依赖 Rust 的高性能和可靠性。这些案例虽非重点，但足以证明 Rust 的通用性。</p>
<p>安全只是 Rust 的敲门砖。它的真正魅力在于，它让开发者在性能、可靠性和表达力之间找到平衡。你可以编写接近硬件的低级代码，也可以构建抽象层次高、逻辑清晰的高级系统，而不必被内存管理或并发问题拖累。Rust 不是“安全的 C++”，而是一门重新定义系统编程的语言。</p>
<h2>重新定义 Rust 的价值</h2>
<p>Rust 的魅力远不止「安全」二字。它以所有权模型和编译时检查为开发者卸下内存管理的重担，却从不以安全为唯一目标。性能、表达力与灵活性的融合，让 Rust 成为系统编程的新标杆。放下「安全语言」的刻板标签，我们应重新审视 Rust 的初心：赋予开发者自由与掌控力，构建可靠而高效的未来。无论是优化性能的极致追求，还是优雅代码的艺术表达，Rust 都以其独特的设计，邀请我们探索系统编程的无限可能。</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Rust' ]</category>
        </item>
    </channel>
</rss>