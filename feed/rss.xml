<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Hsuan's Space</title>
        <link>https://quarkpixel.github.io</link>
        <description>Hsuan's personal blog about tech, life, and thoughts</description>
        <lastBuildDate>Wed, 27 Aug 2025 06:46:31 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Feed for Node.js</generator>
        <language>zh-CN</language>
        <image>
            <title>Hsuan's Space</title>
            <url>https://quarkpixel.github.io/logos/large-black.svg</url>
            <link>https://quarkpixel.github.io</link>
        </image>
        <copyright>All rights reserved 2025, Xuancong Meng</copyright>
        <item>
            <title><![CDATA[完美主义是否也是一种「园丁妄想症」？]]></title>
            <link>https://quarkpixel.github.io/p/250810-perfectionism-also-kind-of-gardener-delusions</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250810-perfectionism-also-kind-of-gardener-delusions</guid>
            <pubDate>Sun, 10 Aug 2025 15:25:00 GMT</pubDate>
            <description><![CDATA[由 Eltrac 的文章《园丁妄想症》引发的思考。]]></description>
            <content:encoded><![CDATA[<p>读完 Eltrac 的文章《<a href="https://www.geedea.pro/posts/%E5%9B%AD%E4%B8%81%E5%A6%84%E6%83%B3%E7%97%87/">园丁妄想症</a>》，<del>感觉被骂了</del> 引发了自己很多的反思。推荐去读原文。</p>
<p>简单回顾一下文章的核心概念：「园丁妄想症」描述的是人们看到他人的完美成果后，立刻幻想自己也能拥有，却忽略了背后的过程、动机和现实条件等一整条链路。结果就是冲动行动，浪费资源，最终一事无成。</p>
<p>但我发现，完美主义者的行为模式与此惊人相似——只不过他们不是在羡慕别人的花园，而是在追逐一个虚幻的「完美花园」。</p>
<h2>相似的行为模式</h2>
<p>读到原文中这段话时，我感到一种奇妙的熟悉感：</p>
<blockquote>
<p>之后，我急于调整个人主页的设计，几乎没有太多思考，把代码结构搞得乱七八糟，最后也没做出什么名堂。最好笑的是，两个小时过去了，我还在打磨那个「作品集」页面，而本来想做的 Now 页面和数字花园压根还没开始。</p>
<p>就像开头故事里的小李，忙活了一下午也没种花，而是铺路，可最后路也没修好。</p>
</blockquote>
<p>这不就是完美主义的经典表现吗？</p>
<p>完美主义者经常陷入这样的困境：为了追求一个理想化的结果，他们在细节上无休止地打磨，却忽略了真正重要的目标。他们害怕不完美，所以宁愿停留在 “准备阶段”，也不愿意面对现实的不完美。</p>
<h2>完美主义的「内在妄想」</h2>
<p>园丁妄想症的核心是对<strong>他人成果</strong>的幻想，而完美主义则是对<strong>理想自我</strong>的幻想。</p>
<p>想象一下：你准备写一篇文章，脑海中浮现的是一篇逻辑完美、文笔优雅、观点深刻的作品。你甚至能想象读者读完后的赞叹，想象这篇文章为你带来的认可。这种 “完美图景” 一旦形成，现实中的任何不足都变得无法忍受。</p>
<p>这就是完美主义的妄想性质：<strong>它让你爱上了一个不存在的理想版本，而不是专注于真实的创作过程</strong>。</p>
<p>更有意思的是，完美主义者往往会在脑海中构建一个 “完美的自己”——这个自己永远不会犯错，永远能产出完美的作品，永远不需要修改和调整。就像园丁妄想中的小李幻想朋友来花园做客的场景一样，完美主义者也在幻想一个根本不存在的“完美状态”。</p>
<p>结果呢？真实的创作变得痛苦不堪，因为每一个不完美的细节都在提醒你：现实与幻想之间的差距。</p>
<h2>为什么完美主义更隐蔽</h2>
<p>园丁妄想症相对容易识别，因为它的指向很明确：<strong>别人有的，我也想要</strong>。当你发现自己在模仿他人时，理性很容易介入。</p>
<p>但完美主义不同。它披着&quot;追求卓越&quot;的外衣，社会文化还在不断强化这种价值观。<strong>“精益求精”、“不断进步”、“追求完美”</strong>——这些词汇听起来都那么正面，谁敢说自己反对呢？</p>
<p>这种文化包装让完美主义变得极其隐蔽。你很难意识到自己陷入了一种妄想，因为周围的声音都在告诉你：这样做是对的。</p>
<p>更糟糕的是，完美主义还有一个强大的自我欺骗机制：<strong>它总是能找到合理的理由</strong>。“我只是想把这件事做好”、“细节决定成败”、“我对自己要求高一点有什么错”——听起来都很有道理，不是吗？</p>
<p>但问题在于，这种&quot;要求高&quot;往往脱离了现实的约束条件。就像文中的小李忘记了自己其实并不喜欢花一样，完美主义者也忘记了自己的真实目的是什么。</p>
<h2>同样忽略过程的本质</h2>
<p>原文提到，园丁妄想的核心问题是 “只看结果，忽略过程”。完美主义在这一点上如出一辙。</p>
<p>完美主义者眼中只有那个完美的终点，对到达那里的路径却缺乏耐心。他们希望第一稿就是完美的，希望第一次尝试就成功，希望跳过所有笨拙和混乱的中间状态。</p>
<p>这种对过程的厌恶导致了一个悖论：<strong>为了追求完美，他们反而拒绝了通往完美的唯一路径——不完美的练习</strong>。</p>
<p>我自己写代码时就经常遇到这种情况。明明知道 “先让它跑起来，再让它跑得好” 的道理，但还是忍不住想要一次性写出 “完美” 的代码。结果往往是在架构设计上纠结半天，最后什么都没写出来。</p>
<p>真正的创作过程永远是混乱的：第一稿是垃圾，第二稿还是垃圾，第三稿开始有点样子……这个过程既必要又痛苦，但完美主义者往往选择逃避这种痛苦。</p>
<h2>相通的解决之道</h2>
<p>既然完美主义本质上是一种「内在的园丁妄想」，那么原文的解决方案同样适用。</p>
<p><strong>专注自己的花园</strong>，在完美主义语境下就是：<strong>专注真实的需求和过程，而不是虚幻的完美标准</strong>。</p>
<p>原文提到的几个要点都很有启发：</p>
<ol>
<li><p><strong>审视动机</strong>：你追求完美是因为真的需要，还是因为恐惧？很多时候，完美主义源于对失败、批评或拒绝的恐惧，而不是对质量的真实需求。</p>
</li>
<li><p><strong>接受过程的不完美</strong>：就像邻居是从一两簇花开始，慢慢浇灌出花园一样，任何创作都需要从粗糙的开始逐步完善。</p>
</li>
<li><p><strong>关注内在热情</strong>：真正的园丁种花是因为喜欢，不是为了炫耀。真正的创作者写作是因为有话要说，不是为了证明自己完美。</p>
</li>
<li><p><strong>允许删除和舍弃</strong>：原文建议不要把冲动想法放进 GTD 系统，因为「如果一件事情对你来说真的重要，你的大脑会记住的」。同样，如果一个完美主义的标准让你痛苦而无产出，也许它根本就不重要。</p>
</li>
</ol>
<h2>结语</h2>
<p>我也在实践这个道理。我自知我的文笔不好，换做以前的自己可能根本不会选择去写个人博客。我不敢把自己不好的一面，或者说「未来的我看到会觉得像傻逼」的东西放出来。</p>
<p>我现在正尝试努力克服自己的「不包容」：包容自己，包容他人。</p>
<p>也许这就是摆脱&quot;园丁妄想症&quot;的真正含义，<strong>停止追逐虚幻的完美花园，开始享受真实的种植过程</strong>。</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category></category>
        </item>
        <item>
            <title><![CDATA[TextAnimation 的实现细节]]></title>
            <link>https://quarkpixel.github.io/p/250721-details-in-text-animation</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250721-details-in-text-animation</guid>
            <pubDate>Mon, 21 Jul 2025 12:44:11 GMT</pubDate>
            <description><![CDATA[深入解析 svelte-text-animation 组件的技术实现与最新优化]]></description>
            <content:encoded><![CDATA[<p>在<a href="./250525-tech-stack-in-hsuans-space">之前的文章</a>中，我简单提到了自己开发的 <a href="https://github.com/QuarkPixel/svelte-text-animation"><code>svelte-text-animation</code></a> 组件。这个组件最初是为了本站首页 Landing 部分的文字动画效果而设计的，后来觉得特别好用就抽象成了一个独立的组件。最近对组件进行了一些优化更新，借此机会来详细介绍一下这个库的实现细节。</p>
<h2>核心设计思路</h2>
<h3>基本原理</h3>
<p>整个动画的核心思想非常简洁：<strong>使用高斯函数叠加边缘递减函数</strong>，为文本中的每个字符计算一个效果强度值，然后通过回调函数将这个强度转换为具体的样式。</p>
<p><img src="https://raw.githubusercontent.com/QuarkPixel/svelte-text-animation/master/assets/example.gif" alt="Demo"></p>
<h3>数学模型</h3>
<p>动画效果由两个关键函数组成：</p>
<ol>
<li><strong>高斯函数</strong>：控制效果在文本中的空间分布</li>
<li><strong>边缘递减函数</strong>：确保动画在起始和结束时平滑过渡</li>
</ol>
<h2>最新优化：更平缓的边缘递减函数</h2>
<h3>原有实现的局限性</h3>
<p>在之前的版本中，边缘递减函数使用的是简单的二次函数：</p>
<p>$$
f_{\text{old}}(p) = 4p(1 - p)
$$</p>
<p>其中 $p$ 表示动画进度（progress）。这个函数确实能够满足边界条件：在 $p = 0$ 和 $p = 1$ 时函数值为 0，在 $p = 0.5$ 时达到最大值 $1$，实现了平滑过渡的目标。</p>
<p>然而，这种实现存在一个显著问题：<strong>动画效果仅在进度接近 0.5 时才能完全展现，其他位置的效果都会被显著削弱</strong>。这意味着动画的大部分时间里，文字效果都无法达到理想状态。</p>
<h3>新的数学方案</h3>
<p>经过深入思考和数学推导，我设计了一个更高阶的多项式函数：</p>
<p>$$
f_{\text{new}}(p) = 1 - (2p - 1)^{2n}
$$</p>
<p>其中 $n$ 对应新增的 <code>edgeFlatness</code> 参数（默认值为 5），用于控制函数的平缓程度。</p>
<p>这个改进后的函数具有以下优秀特性：</p>
<ul>
<li><strong>保持边界条件</strong>：当 $p = 0$ 或 $p = 1$ 时，函数值依然为 $0$</li>
<li><strong>峰值位置不变</strong>：在 $p = 0.5$ 时函数值仍为 $1$</li>
<li><strong>中间区域显著改善</strong>：通过调整 $n$ 参数，可以让更大范围内的进度值都接近最大效果强度</li>
</ul>
<h3>函数特性分析</h3>
<p>通过数学分析可以发现，当 $n = 1$ 时，新函数退化为原有的二次函数。而当 $n &gt; 1$ 时，函数变为 $2n$ 次多项式，相当于在原有基础上增加了一个可调节的平缓度参数。</p>
<center>
<img class="outline outline-[#26796D] outline-3 w-[50%]" src="/assets/20250721-0.gif" alt="edgeFactor 函数演示" />
<em>不同 flatness 值下的边缘递减函数对比</em>
</center>

<p>从图中可以直观看出，随着 <code>flatness</code> 参数的增大，函数在中间区域变得更加平缓，这意味着动画效果在更大的进度范围内都能保持接近最大强度，显著提升了整体的视觉表现。</p>
<h2>核心实现解析</h2>
<h3>效果强度数组生成算法</h3>
<pre><code class="language-typescript">function generateEffectArray(
	length: number,
	progress: number,
	spread: number,
	flatness: number
): number[] {
	// 计算边缘递减因子
	const edgeFactor = 1 - Math.pow(2 * progress - 1, 2 * flatness);
	const result = new Array(length).fill(0);

	// 早期返回优化：当边缘因子为负时直接返回零数组
	if (edgeFactor &lt;= 0) {
		return result;
	}

	// 计算当前动画焦点在文本中的位置
	const offset = progress * (length + 2 * spread + 1) - spread - 1;

	// 优化计算范围，避免不必要的高斯函数计算
	const startIdx = Math.max(0, Math.floor(offset - spread * 3));
	const endIdx = Math.min(length - 1, Math.ceil(offset + spread * 3));

	for (let i = startIdx; i &lt;= endIdx; i++) {
		const z = (i - offset) / spread;
		const zSquared = z * z;

		// 性能优化：当 z² &gt; 9 时，e^(-z²) &lt; 0.01，可以忽略
		if (zSquared &lt; 9) {
			result[i] = Math.exp(-zSquared) * edgeFactor;
		}
	}

	return result;
}
</code></pre>
<h3>关键优化策略</h3>
<ol>
<li><strong>早期返回优化</strong>：当边缘因子小于等于 0 时，直接返回零数组，避免后续无意义的计算</li>
<li><strong>智能范围限制</strong>：仅对可能产生显著效果的字符范围进行计算，大幅降低计算复杂度</li>
<li><strong>高斯函数截断</strong>：利用指数函数的快速衰减特性，当距离过远时直接跳过计算</li>
</ol>
<h2>API 设计</h2>
<h3>核心参数接口</h3>
<pre><code class="language-typescript">interface Props {
	text: string;                                 // 要进行动画的文本内容
	progress: number;                             // 动画进度，取值范围 [0, 1]
	spread?: number;                              // 效果扩散半径，默认 3
	edgeFlatness?: number;                        // 边缘平缓度，默认 5
	styleCallback: (intensity: number) =&gt; string; // 强度到样式的转换函数
	innerClassName?: string;                      // 字符容器的 CSS 类名
}
</code></pre>
<h3>实际使用示例</h3>
<pre><code class="language-svelte">&lt;TextAnimation
    text=&quot;Hello, World!&quot;
    {progress}
    spread={4}
    edgeFlatness={6}
    styleCallback={(intensity) =&gt; `
        transform: scale(${1 + intensity * 0.5});
        color: rgb(${255}, ${Math.floor(255 * intensity)}, ${Math.floor(255 * intensity)});
    `}
/&gt;
</code></pre>
<p>你可以在 <a href="https://svelte.dev/playground/434018293cfb415b925f19b47ef4a85c?version=5.33.1">Svelte Playground</a> 中直接体验这个组件的效果。</p>
<p>实际应用场景可以参考本博客首页的 Landing 部分，对应的源码实现：<a href="https://github.com/QuarkPixel/QuarkPixel.github.io/blob/master/src/routes/Landing.svelte">Landing.svelte</a>。</p>
<hr>
<h2>总结</h2>
<p><code>svelte-text-animation</code> 通过精心设计的数学函数组合，实现了既平滑又视觉效果出色的文字动画。最新版本中边缘递减函数的优化，通过引入可调节的平缓度参数，显著提升了动画在整个进度范围内的表现效果。</p>
<p>这种基于数学模型的设计方法不仅保证了动画的流畅性，还为开发者提供了充分的自定义空间。如果你对这个组件感兴趣，欢迎在 <a href="https://github.com/QuarkPixel/svelte-text-animation">GitHub</a> 上为项目点个 Star 😆</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>['Technique'</category>
            <category>'Web']</category>
        </item>
        <item>
            <title><![CDATA[HDR 在被滥用吗]]></title>
            <link>https://quarkpixel.github.io/p/250720-is-hdr-being-overused</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250720-is-hdr-being-overused</guid>
            <pubDate>Sun, 20 Jul 2025 11:24:30 GMT</pubDate>
            <description><![CDATA[谈谈现今 HDR 的一些问题]]></description>
            <content:encoded><![CDATA[<script>
import BiliPlayer from '$lib/components/BiliPlayer.svelte';
</script>

<p><strong>这是一篇讨论帖，由于本人没有实际上手过新的操作系统，故所有内容均来自网络，内容可能有误。欢迎发表自己的看法～</strong></p>
<h2>引言</h2>
<p>起因来自一条视频，展示了 Apple 在新系统的画笔中支持选择 <a href="https://en.wikipedia.org/wiki/High_dynamic_range">HDR</a> 颜色。</p>
<BiliPlayer bv="BV1TW33zdE2T" />

<p>给我的第一感受就是：<strong>怪</strong>。</p>
<p>我其实能理解为什么 Apple 会允许选择 HDR 颜色，让系统整体对 HDR 有更深度的融合。但我不禁要问：这样的 HDR 真的合理吗？设计生态真的准备好了吗？</p>
<p>我的担心是：HDR 技术为 UI 带来了更丰富的视觉表现力，但在缺乏统一设计语言和生态支持的前提下，Apple 等厂商的 &quot;开放式 HDR
策略&quot; 反而可能破坏用户界面的一致性，增加设计负担。</p>
<h2>HDR 的潜力</h2>
<p>HDR 如果处理得好的话，UI 确实可以美到飞起。</p>
<p>HDR 不只是让画面更亮、更艳，更重要的是它为界面设计引入了 &quot;亮度空间&quot; 这一新的表达维度。从传统的颜色/对比度控制，拓展到了真实光强的建构。得益于此，HDR
可作为界面结构化、分层与焦点引导的新工具。例如：</p>
<ul>
<li><p>通过局部高亮引导用户注意力，而非依赖颜色或动画；</p>
</li>
<li><p>模拟真实光源制造视觉层次感，从而增强沉浸体验；</p>
</li>
<li><p>赋予 UI 元素不同的“光学存在感”，区分主次关系。</p>
</li>
</ul>
<p>这些观点指向一个共识：<strong>HDR 是视觉强化的强力工具，但前提是 &quot;设计得好&quot; ，且配合统一的设计语言与生态标准。</strong> 否则，它也可能成为破坏体验的利器。</p>
<h2>问题在于 HDR 没有统一标准</h2>
<p>但现实情况是，我们的 HDR UI 体验远没有达到理想状态。</p>
<h3>系统层面的设计不一致</h3>
<p>最明显的问题是视觉连贯性的缺失。我们经常能看到 HDR 视频在普通 UI 界面上播放，导致整体界面看起来发灰、不协调。这种 &quot;接缝感&quot;
破坏了用户界面应有的统一性。</p>
<p>还有 Reddit
用户提到 <a href="https://www.reddit.com/r/appletv/comments/x2al6l/youtube_adverts_causing_huge_delay_because_tv/">YouTube 广告因 HDR 切换导致画面延迟和色彩跳变</a>
，严重影响观看体验。</p>
<p>这些问题的根源在于：<strong>HDR 在系统 UI 中的体验不连贯，打断了用户的视觉流，这是设计上的失败。</strong></p>
<h3>缺乏设计指导下的 &quot;自由发挥&quot;</h3>
<p>当技术门槛降低，HDR 变得人人可用时，缺乏设计规范的约束就会带来问题。</p>
<p>我们确实看到了一些令人担忧的现象：抖音上有用户开始使用带有HDR高亮的表情包进行恶搞，这些内容因为比平常的图片更亮而获得关注。</p>
<details>
  <summary>[视频] 这年头，表情包都自带HDR了？</summary>
  <BiliPlayer bv="BV1HkTuzcE7V" />
</details>

<p>类似的情况还出现在广告投放中，HDR被用作粗暴的注意力抓取工具，而不是精心设计的视觉体验。这些现象本身不是核心问题，而是设计缺位的副作用。</p>
<details>
  <summary>[视频] 野生的网页 HDR 广告</summary>
  <BiliPlayer bv="BV1sw4m1d7L1" />
</details>


<p><strong>HDR UI 当前的问题不是 HDR 本身，而是没有明确的 &quot;设计语言&quot; 和规范来驾驭它。</strong></p>
<h3>生态支持的不成熟</h3>
<p>更深层的问题在于，我们的数字生态还没有准备好迎接 &quot;全面HDR化&quot;。</p>
<p>第三方应用、浏览器、视频播放器对 HDR 的支持参差不齐，导致用户在不同场景下体验到的 HDR 效果千差万别。有时候 HDR
让界面更加精致，有时候又让整体显得突兀。这种不可预测性正是设计大忌。</p>
<p>Steam 社区论坛上有用户抱怨 <a href="https://steamcommunity.com/discussions/forum/11/7074686901648727412/">HDR 显示器效果的糟糕</a>
，虽然不知道具体的原因，但我们可以明确的是现在的 HDR 领域无比混乱。</p>
<h2>结语</h2>
<p>回到开头的问题：Apple 开放 HDR 究竟是好事还是坏事？</p>
<p>我的观点是：<strong>HDR是好工具，但应该被认真对待。</strong></p>
<p>我们需要的不是 HDR 的全面开放，而是有设计指导的 HDR 应用。Apple 等厂商在推广 HDR 技术时，应该投入更多精力建立统一的设计规范和使用标准；软件厂商在对接
HDR 技术时，也更应该谨慎对待。</p>
<h2>参考文章</h2>
<ul>
<li><a href="https://medium.com/design-bootcamp/what-hdr-in-ui-tells-us-about-the-future-of-digital-perception-bb3d9133d1f6">HDR in UI: Designing Perception Through
Brightness</a></li>
<li><a href="https://medium.com/design-bootcamp/the-rise-of-hdr-ui-not-a-visual-gimmick-but-a-paradigm-shift-in-perceptual-logic-8062247f72dd">HDR UI and EDR: Rethinking Brightness in Interface Design</a></li>
<li><a href="https://medium.com/design-bootcamp/is-your-ui-design-file-still-representing-the-final-output-in-the-hdr-ui-era-4bd4fb1f4b9d">Is Your UI Design File Still Representing the Final Output in the HDR UI Era?</a></li>
</ul>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Thinking'</category>
            <category>'Visual' ]</category>
        </item>
        <item>
            <title><![CDATA[夏长，云懒。]]></title>
            <link>https://quarkpixel.github.io/p/250712-summer-clouds</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250712-summer-clouds</guid>
            <pubDate>Sat, 12 Jul 2025 07:15:00 GMT</pubDate>
            <description><![CDATA[记录平时拍摄的云]]></description>
            <content:encoded><![CDATA[<p><strong>夏日的云，也想慵懒。</strong></p>
<p>平时喜欢去天台散心：没有喧嚣，只有自己。夏日的云和其它时候都不一样。从专业术语的角度出发，我爱看夏天的<a href="https://zh.wikipedia.org/wiki/%E7%A7%AF%E4%BA%91">积云</a>。记这些年来拍到的夏日云：</p>
<div class="bg-surface-100-900 outline-9 rounded-xl my-2 outline-surface-100-900 grid grid-cols-3 grid-rows-6 gap-2 [&_img]:w-full [&_img]:h-full [&_img]:object-cover [&_img]:m-0 *>rounded-xl *>shadow-lg *>overflow-hidden *>bg-gray-200">
  <div class="col-start-1 col-span-2 row-start-1 row-span-2">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332223628-62631dabb337"/>
  </div>
  
  <div class="col-start-3 col-span-1 row-start-1 row-span-3">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332223533-993114881882"/>
  </div>
  
  <div class="col-start-1 col-span-1 row-start-3 row-span-3">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332223583-0d94cb2911f7"/>
  </div>
  
  <div class="col-start-2 col-span-2 row-start-4 row-span-1">
    <img alt="clouds" src="https://images.unsplash.com/photo-1695450148576-675cab2c9215"/>
  </div>
  
  <div class="col-start-2 col-span-1 row-start-3 row-span-1">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332223520-1278796028f5"/>
  </div>
  
  <div class="col-start-3 col-span-1 row-start-5 row-span-2">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332222129-6e44eb7e3f29"/>
  </div>
  
  <div class="col-start-2 col-span-1 row-start-5 row-span-2">
    <img alt="clouds" src="https://images.unsplash.com/photo-1727843062665-040b10410226"/>
  </div>
  
  <div class="col-start-1 col-span-1 row-start-6 row-span-1">
    <img alt="clouds" src="https://images.unsplash.com/photo-1696332223050-253b7b199a68"/>
  </div>
</div>
<div class="-mt-1"><a class="text-surface-400-600 font-noto-sans text-sm" href="https://unsplash.com/@quarkpixel">Unsplash @quarkpixel</a></div>

]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Photography' ]</category>
        </item>
        <item>
            <title><![CDATA[重做网页布局排版]]></title>
            <link>https://quarkpixel.github.io/p/250701-remake-typography</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250701-remake-typography</guid>
            <pubDate>Tue, 01 Jul 2025 07:15:00 GMT</pubDate>
            <description><![CDATA[从 Skeleton 转向 Tailwind Typography]]></description>
            <content:encoded><![CDATA[<p>许久之前就无法忍受网页的排版。作为一个博客网站，文字的呈现效果是至关重要的。在之前介绍<a href="./250525-tech-stack-in-hsuans-space">网站使用的技术栈</a>时就提到我使用了 Skeleton 作为 UI 框架。然而这个框架在排版方面的表现很不尽如人意。我趁着最近在大量升级网站的机会，将排版系统从 Skeleton + MDsveX 自定义样式转向了 Tailwind Typography + MDsveX 默认对接。</p>
<center>
<img class="outline outline-[#808CA9] outline-4 rounded-[1px] mb-[44px]" src="/assets/20250701-0.webp" alt="" />
<em>左图：新版｜右图：老版</em>
</center>

<h2>使用 Skeleton 所遇到的问题</h2>
<p><a href="https://skeleton.dev/">Skeleton</a> 是一个非常优秀的 UI 框架，它为 SvelteKit 提供了美观且功能丰富的组件库。在构建网站的导航栏、按钮、卡片等常规 UI 组件时，Skeleton 的表现令人满意。</p>
<p>然而，当面对大量文字排版这样的特定场景时，Skeleton 就不再能胜任。它更着重于 UI，而非排版。在此之前我因为偷懒，就没有想着用专业的排版引擎 😂</p>
<p>此外，即使作为一个 UI 组件集，我认为 Skeleton 在排版方面也远不算合格。它不基于语义化标签作用样式，甚至还将语义化标签的样式都重置了。因此当你直接使用 <code>&lt;h1&gt;</code> 时，它是没有任何样式的。这是因为 Skeleton 要求你为每个标题添加对应的 class：</p>
<pre><code class="language-html">&lt;!-- 没有样式，因为缺少 class --&gt;
&lt;h1&gt;Hello World&lt;/h1&gt;

&lt;!-- “正确” 的使用方式，但很难评 --&gt;
&lt;h1 class=&quot;h1&quot;&gt;Hello World&lt;/h1&gt;
</code></pre>
<p>而这在与 MDsveX 对接时就产生了问题：MDsveX 只生成纯 HTML 结构，这在与 Skeleton 的对接中就出现了问题。因此我不得不为每一个基本元素都写一个包装组件：</p>
<pre><code class="language-bash">➜ HsuansSpace/src/lib/components/typography master ✓ tree .     
.
├── Anchor.svelte
├── BaseList.svelte
├── Blockquote.svelte
├── Code.svelte
├── Del.svelte
├── H1.svelte
├── H2.svelte
├── H3.svelte
├── H4.svelte
├── H5.svelte
├── H6.svelte
├── Hr.svelte
├── Image.svelte
├── Ins.svelte
├── Italic.svelte
├── Keyboard.svelte
├── Mark.svelte
├── OrderedList.svelte
├── P.svelte
├── Pre.svelte
├── Table.svelte
├── TableBody.svelte
├── UnorderedList.svelte
└── index.ts

1 directory, 24 files
</code></pre>
<p>抛去麻烦的问题外，还有一些样式的不兼容等问题就在这样一层又一层的屎山中构建起来了。</p>
<h2>转换为 Tailwind Typography</h2>
<p><a href="https://tailwindcss.com/docs/typography-plugin">Tailwind Typography</a> 是一个官方专门为文章排版设计的插件。它提供了：</p>
<ul>
<li>精心调教的文字间距和行高</li>
<li>优雅的标题层级样式</li>
<li>完善的列表和引用样式</li>
<li>适配不同屏幕尺寸的响应式排版</li>
</ul>
<p>最重要的是，Tailwind Typography 完全基于语义化标签工作，与 MDsveX 的默认渲染完美契合。这意味着我们可以专注于写作内容，不必再为每个 HTML 标签编写包装组件，因为屎山堆叠所导致的样式错误问题也消失了。</p>
<h2>迁移过程</h2>
<p>迁移过程出乎意料地顺利。主要步骤包括：</p>
<ol>
<li>移除 Skeleton 中的文章样式覆盖</li>
<li>配置 Tailwind Typography 插件</li>
<li>为文章容器添加 <code>prose</code> 类</li>
<li>调整默认颜色配置，使其适配 Skeleton 的颜色系统</li>
</ol>
<h2>总结</h2>
<p>有时候，简单的解决方案反而是最好的。Tailwind Typography 专注于解决文章排版这一具体问题，而不是试图成为一个全能的框架。这让它在这个特定场景下的表现远超 Skeleton。</p>
<p>你可以在这里查看完整的 <a href="/test">Markdown 语法测试</a>，体验新的排版效果。</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Develop Diary' ]</category>
        </item>
        <item>
            <title><![CDATA[支持 RSS 订阅啦！]]></title>
            <link>https://quarkpixel.github.io/p/250629-new-rss-feature</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250629-new-rss-feature</guid>
            <pubDate>Sun, 29 Jun 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[添加 RSS Feed 支持，以及其他方面的网站改进]]></description>
            <content:encoded><![CDATA[<p>为博客添加了 RSS 订阅功能！🎉</p>
<p>现在你可以通过 RSS 阅读器订阅本博客的更新了。支持以下几种订阅格式：</p>
<ul>
<li><a href="/feed/rss.xml">RSS 2.0</a></li>
<li><a href="/feed/atom.xml">Atom</a></li>
<li><a href="/feed/feed.json">JSON Feed</a></li>
</ul>
<p>RSS（Really Simple Syndication）是一种很棒的信息获取方式。通过 RSS，你可以在自己喜欢的阅读器中统一管理和阅读订阅的内容，不会错过任何更新，也不用担心算法推荐的干扰。</p>
<p>此外，网站更新的内容还有：</p>
<ul>
<li>Footer 的重置***（新版本的效果我很满意😁）***</li>
<li>友链支持</li>
<li>网站后台监控***（使用 <a href="https://umami.is">Umami</a> 服务）***以及更新 <a href="/privacy">隐私政策</a></li>
<li>首页 Landing 现在可以鼠标交互了✨</li>
</ul>
<p>欢迎订阅本博客的 RSS feed！📮</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Develop Diary' ]</category>
        </item>
        <item>
            <title><![CDATA[Rust 是一门适合 Vibe Coding 的语言]]></title>
            <link>https://quarkpixel.github.io/p/250623-rust-is-suitable-for-vibe-coding</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250623-rust-is-suitable-for-vibe-coding</guid>
            <pubDate>Mon, 23 Jun 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[从安全特性、错误提示和自动化验证的角度，探讨为什么 Rust 可能是最适合 AI 编程的语言]]></description>
            <content:encoded><![CDATA[<p><del>(文章标题有些暴论，李姐万岁)</del></p>
<p><a href="https://en.wikipedia.org/wiki/Vibe_coding">Vibe Coding</a> 是一种借助 AI 生成代码，并通过人机协作快速验证和迭代想法的开发方式。在这种模式下，开发效率高度依赖于两个关键环节：生成代码的初步质量，以及后续验证与修正的可靠性。而 Rust 的诸多语言特性，恰恰能够在这两个环节中提供显著支持。</p>
<h2>语言特性的安全保障</h2>
<p>AI 生成的代码往往存在潜在缺陷，尤其在内存管理、并发控制和边界条件处理等方面容易出现疏漏。考虑这样一个常见场景，生成如下的 C++ 代码：</p>
<pre><code class="language-cpp">// 存在悬垂指针风险
int* createInt() {
    int value = 42; // 局部变量，函数结束时销毁
    return &amp;value;  // 返回局部变量的地址
}
</code></pre>
<p>这段代码在运行时可能导致未定义行为，而编译器往往只会给出警告，甚至完全不报错。但如果 AI 试图在 Rust 中生成类似的代码：</p>
<pre><code class="language-rust">fn create_int() -&gt; &amp;i32 {
    let value = 42; // 局部变量
    &amp;value // 错误：返回局部变量的引用
}
</code></pre>
<p>Rust 编译器会直接拒绝编译，并给出明确的生命周期错误提示：</p>
<pre><code>error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:20
  |
1 | fn create_int() -&gt; &amp;i32 {
  |                    ^ expected named lifetime parameter
  |
  = help: this function&#39;s return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `&#39;static` lifetime, but this is uncommon unless you&#39;re returning a borrowed value from a `const` or a `static`
  |
1 | fn create_int() -&gt; &amp;&#39;static i32 {
  |                     +++++++
help: instead, you are more likely to want to return an owned value
  |
1 - fn create_int() -&gt; &amp;i32 {
1 + fn create_int() -&gt; i32 {
  |
For more information about this error, try `rustc --explain E0106`.
error: could not compile `demo_rust` (bin &quot;demo_rust&quot;) due to 1 previous error
</code></pre>
<p>Rust 的所有权系统、借用检查机制和严格的类型系统，能够在编译阶段拦截许多常见错误。这不仅显著降低了运行时崩溃的风险，也使得 AI 即使生成出不够完善的代码，仍能在编译器指导下逐步逼近正确实现。</p>
<h2>人性化的错误提示</h2>
<p>Rust 编译器所提供的错误信息一向以清晰、详尽而著称。它不只是告诉你「错了」，而是手把手教你「该怎么改」。就像上面的例子中，编译器不仅指出了生命周期问题，还直接建议了两种修复方案：使用 <code>&#39;static</code> 生命周期或返回拥有值。这种详细的错误信息，甚至包含了修复建议，让 AI 能够自主进行多轮修正。开发者则可以将精力集中于更高层的逻辑设计，而不必深入调试每一个低级错误。</p>
<p>相比之下，C++ 的错误信息往往会让人摸不着头脑：</p>
<pre><code>main.cpp:5:13: warning: address of stack memory associated with local variable &#39;value&#39; returned [-Wreturn-stack-address]
    return &amp;value;  // 返回局部变量的地址
            ^~~~~
1 warning generated.
</code></pre>
<p>这样的错误信息对 AI 和开发者都不够友好，即使 AI 大部分时候可以像经验丰富的开发者一样知道问题出现的原因，但这种模糊的提示仍然增加了调试成本。</p>
<h2>编译时检查作为自动化验证</h2>
<p>传统 Vibe Coding 流程中，代码的正确性严重依赖人工测试与审查，这不仅效率低下，也容易引入主观偏差。而 Rust 的编译时检查机制（包括类型安全、生命周期验证、数据竞争检测等）构成了一套自动化、标准化的验证基础。它确保了生成的代码至少在内存安全、数据竞争等基础层面是可信的，从而为后续的功能测试和集成验证节省大量时间。</p>
<p>举个例子，在多线程场景中，即使 AI 生成了可能存在数据竞争的代码，Rust 编译器也会在编译阶段就将其拦截，并引导向使用 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 或其他合适的同步原语的正确方案。这种&quot;编译通过即基本安全&quot;的特性，在快速原型开发中尤为宝贵。</p>
<h2>类型系统的引导作用</h2>
<p>Rust 的类型系统还能够引导 AI 生成更加精确的代码。例如，当处理可能失败的操作时，Rust 的 <code>Result</code> 类型会强制处理错误情况，而不像某些动态语言那样可以随意忽略异常处理。这种「强制正确性」的设计哲学，与 AI 编程中「快速迭代但保证质量」的需求高度契合。</p>
<h2>局限性和现状</h2>
<p>目前，Python 和 JavaScript 在 Vibe Coding 中确实更加普及，主要原因在于它们的生态丰富度和语法简洁性。动态类型语言在原型开发阶段确实更加灵活，而且 AI 训练数据中这些语言的代码占比很大。相比之下，Rust 的学习资源和代码语料仍然相对有限，这在一定程度上限制了 AI 模型对 Rust 的支持深度。</p>
<p>不过，随着 Rust 在系统编程、Web 开发和区块链等领域的快速发展，以及 Microsoft、Google 等大厂的推动，这一差距正在逐渐缩小。</p>
<h2>结论</h2>
<p>Rust 通过其内在的安全机制、友好的诊断信息以及强大的编译时验证，为 Vibe Coding 提供了一条兼具高可靠性和自动化程度的开发路径。虽然它可能不如 Python 那样&quot;即写即跑&quot;，但在需要高质量、可维护代码的场景中，Rust 的这些特性能够显著提升人机协作的效率和成果质量。</p>
<p>随着 AI 编程工具的不断发展和 Rust 生态的日益成熟，我相信会有越来越多的开发者发现：让 AI 在 Rust 的约束下编写代码，往往能够得到更加可靠和优雅的解决方案。这种&quot;约束即自由&quot;的开发体验，也许正是未来 AI 辅助编程的理想形态。</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>['Rust'</category>
            <category>'AI']</category>
        </item>
        <item>
            <title><![CDATA[上线评论功能～]]></title>
            <link>https://quarkpixel.github.io/p/250616-new-giscus-module</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250616-new-giscus-module</guid>
            <pubDate>Mon, 16 Jun 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[添加基于 Giscus 的评论系统]]></description>
            <content:encoded><![CDATA[<p>终于给博客加上了评论功能！🎉</p>
<p>选用了 <a href="https://giscus.app/">giscus</a> 作为评论系统，它基于 GitHub Discussions，完全开源且免费。最重要的是，它支持 Markdown 语法，可以让我们能更好地交流想法。</p>
<p>现在，你可以在每篇文章的底部看到评论区了。欢迎来聊聊天呀～</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Develop Diary' ]</category>
        </item>
        <item>
            <title><![CDATA[也许我们早已在电车难题中做出了选择？]]></title>
            <link>https://quarkpixel.github.io/p/250609-the-trolley-problem-and-suicide</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250609-the-trolley-problem-and-suicide</guid>
            <pubDate>Mon, 09 Jun 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[聊聊阻止自杀与电车难题]]></description>
            <content:encoded><![CDATA[<p>最近我在思考一个问题：电车难题的选择与阻止自杀的抉择是否有着相似的本质？</p>
<h2>引子：一个假设性思想实验</h2>
<p>最初的思考源于一个假设：</p>
<blockquote>
<p>假设世界有这样一条设定**（尽管价值观未必正确，但有助于讨论）<strong>：存在天堂，只有通过自杀</strong>（主观选择死亡）**的人因其&quot;勇敢&quot;而获得更好的待遇，而非自主死亡的人则命运平庸。</p>
<p>在此设定下，一个人选择自杀，另一人阻止他，是否正确？</p>
</blockquote>
<p>这看似荒谬，但换个角度思考：<strong>选择自杀的人往往因极度痛苦而寻求解脱</strong>。自杀对他们而言，如同进入&quot;天堂&quot;或摆脱苦难。从这点看，自杀的动机与&quot;天堂假设&quot;殊途同归：主体都追求更好的结果。</p>
<p>但前提是，若自杀未遂，生活未改善，痛苦依旧。关键问题是：<strong>若救下自杀者却无法善待他，阻止自杀是否成了错误？</strong></p>
<h2>与电车难题的类比</h2>
<p>我们可以将此与<strong>电车难题</strong>类比：</p>
<ul>
<li><strong>一人（自杀者）</strong>：若不拉杆**（不阻止自杀）<strong>，他得以&quot;解脱&quot;</strong>（如同进入天堂或摆脱痛苦）**</li>
<li><strong>五人（在意他的人）</strong>：泛指任何得知自杀后会伤心的人，如亲友</li>
<li><strong>抉择</strong>：拉杆**（阻止自杀）<strong>亦或不拉杆</strong>（放任自杀）**</li>
</ul>
<h2>道德权衡的复杂性</h2>
<p>由此，问题转化为：</p>
<p><strong>不拉杆</strong>：自杀者解脱，但在意他的人因失去他而痛苦。</p>
<p><strong>拉杆</strong>：自杀者被救下，若未被善待，则继续痛苦；在意他的人免于悲伤。</p>
<p>阻止自杀的人做错了吗？我的答案是：<strong>没有</strong>。他只是做出了电车难题中的选择，权衡了个体解脱与他人的情感损失。同样，若有人选择不阻止自杀，也不应苛责，因为这也是基于个人价值观的决定。</p>
<h2>我们早已做出的选择</h2>
<p>那么，对于电车难题中的拉杆抉择，我们是否早已在生活中做出了选择？</p>
<p>在&quot;被救者未被善待&quot;的前提下，阻止自杀可能让痛苦延续，类似电车难题中牺牲一人救多数的道德困境。然而，若救下的人能被善待，痛苦得以缓解，这场抉择的意义便截然不同。</p>
<h2>结语</h2>
<p>或许，电车难题与阻止自杀的共通之处在于：我们都在有限的信息与复杂的道德权重中挣扎。拉杆与否，没有绝对的正误，<strong>关键在于后续的善待能否实现</strong>。</p>
<p>如果我们能确保救下的灵魂被温柔以待，电车难题的拉杆，或许早已有了答案。否则，我们的选择可能只是将痛苦从一方移到另一方，永远在伦理的灰色地带徘徊。</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>['Thinking']</category>
        </item>
        <item>
            <title><![CDATA[Hsuan's Space 中用到的技术栈]]></title>
            <link>https://quarkpixel.github.io/p/250525-tech-stack-in-hsuans-space</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250525-tech-stack-in-hsuans-space</guid>
            <pubDate>Sun, 25 May 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[谈谈本站的开发历程]]></description>
            <content:encoded><![CDATA[<p>关于「我要做一个关于自己的网页」这个 Flag 我已经立了若干年了，最近这段时间终于有动力来完成它。尝试了没有接触过的技术，花了近半个月的时间，完成了网页的搭建。</p>
<p><img src="https://wakatime.com/badge/user/018b19a3-343c-48f6-8ba9-5713e3a014cc/project/e4f1a103-1fe2-4a7b-afe8-35b4df2164b6.svg?style=flat-square" alt="Wakatime badage">
<em>Time in this web project over all time</em></p>
<p>本站采用了现代化的 Web 开发技术栈，主要包括：SvelteKit、TailwindCSS、MDsveX 和 Skeleton UI.</p>
<h2>1. 字体</h2>
<p>正文部分使用 <a href="https://github.com/lxgw/LxgwWenKai">霞鹜文楷</a>。</p>
<h4>其余字体</h4>
<ul>
<li>Noto Serif SC Variable</li>
<li>Noto Sans SC Variable</li>
<li>Caveat Variable</li>
<li>Gravitas One</li>
</ul>
<p>值得注意的是，本网站使用了<a href="https://chinese-font.netlify.app/zh-cn/online-split/">字体分包</a>技术，由<a href="https://chinese-font.netlify.app/zh-cn/">中文网字计划</a>支持。因此在初次访问网站时，字体会有很独特的加载顺序。</p>
<h2>2. 动画</h2>
<h3>可变字体动画</h3>
<p>使用自己做的另外一款组件<a href="https://github.com/QuarkPixel/svelte-text-animation"><code>svelte-text-animation</code></a>，这款组件的开发是在网页的开发过程中想到的灵感，就花了差不多一个下午的时间来实现。整体效果还是很惊艳的，用在了首页 Landing
的部分 😆。</p>
<p>具体实现的细节其实很是很简单的，使用一个高斯函数叠加上一个边缘递减函数，就可以实现一个平滑的动画效果。</p>
<h3>Logo 动画</h3>
<p>我尝试了市面上很多的 SVG 动画库，但是要么就是太过臃肿，要么就是实现的效果很奇怪，没法做到我要求的“点对点移动”的效果。于是我心一狠，直接手撕了一个SVG动画引擎。其实实际实现起来，没有想象的那么复杂。这也多亏了
Svelte 大量的内置函数，使用起来体验很不错。</p>
<script>
    import Logo from '$lib/components/Logo.svelte';
    import { bounceOut, elasticOut } from 'svelte/easing';
	let logoOfficial = true;
</script>

<p>&lt;button
  class=&quot;mt-20 mb-3 w-full flex justify-around gap-10 _:h-30 _:w-40&quot;
  onmouseenter={() =&gt; logoOfficial = false}
  onmouseleave={() =&gt; logoOfficial = true}</p>
<blockquote>
</blockquote>
<pre><code>&lt;Logo
    official={logoOfficial}
    easing={elasticOut}
/&gt;
&lt;Logo
    official={logoOfficial}
/&gt;
&lt;Logo
    official={logoOfficial}
    easing={bounceOut}
/&gt;
</code></pre>
</button>

<div align="center" class="mb-15 opacity-65 font-gravitas-one">↑ Hover Me ↑</div>

<h4>核心代码：</h4>
<pre><code class="language-typescript">// Derive interpolated path coordinates
let interpolatedPaths: Shape[] = $derived(
	paths.map((path) =&gt;
		path.initial.map((start, i) =&gt; {
			const end = path.target[i];
			const x = start[0] + (end[0] - start[0]) * path.tween.current;
			const y = start[1] + (end[1] - start[1]) * path.tween.current;
			return [x, y];
		})
	)
);

// Derive SVG path d attributes
let dValues: string[] = $derived(
	interpolatedPaths.map((points) =&gt; `M${points.map((point) =&gt; point.join(&#39; &#39;)).join(&#39;L&#39;)}Z`)
);
</code></pre>
<h3>Header 的背景噪声图</h3>
<p>具体实现是使用一张噪声纹理图</p>
<center>
<p>
    <img src="/noise-texture.png" alt>
    <em>噪声纹理图</em>
</p>
</center>

<h5>但由于不同屏幕尺寸可能会导致纹理图发糊。因此我做了这些工作：</h5>
<ul>
<li>添加属性 <code>image-rendering: pixelated;</code>，具体属性说明参见<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering">MDN</a></li>
<li>动态计算图片展示大小，使得图片可以1:1像素展示在显示器上：</li>
</ul>
<pre><code class="language-typescript">function calcNoiseSize() {
	const dpr = window.devicePixelRatio || 1;
	noiseTextureSize = NOISE_TEXTURE_SIZE / dpr;
}

if (browser) {
	calcNoiseSize();
}

onMount(() =&gt; {
	window.addEventListener(&#39;resize&#39;, calcNoiseSize);

	return () =&gt; window.removeEventListener(&#39;resize&#39;, calcNoiseSize);
});
</code></pre>
<h3>Marquee</h3>
<p>页面内所有的跑马灯效果均使用 <a href="https://github.com/selemondev/svelte-marquee"><code>svelte-marquee</code></a> 组件实现</p>
<h3>Markdown 渲染</h3>
<p>使用 <a href="https://mdsvex.pngwn.io/">MDsvex</a> 实现对 md 的渲染</p>
<h2>部署和性能</h2>
<p>项目使用 <code>@sveltejs/adapter-static</code> 生成静态网站，通过 GitHub Pages 进行部署。得益于 Svelte 的优秀性能和静态站点生成的特性，网站具有：</p>
<ul>
<li>快速的首屏加载</li>
<li>优秀的 SEO 表现</li>
<li>简单可靠的部署流程</li>
</ul>
<p>如果你对这个项目感兴趣，可以在 <a href="https://github.com/QuarkPixel/QuarkPixel.github.io">GitHub</a> 上查看源代码，项目代码采用 GPLv3 许可证开源。</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>['Web'</category>
            <category>'Develop Diary']</category>
        </item>
        <item>
            <title><![CDATA[我从未将 Rust 视作一门「安全」的语言]]></title>
            <link>https://quarkpixel.github.io/p/250523-never-regarded-rust-as-safety</link>
            <guid isPermaLink="false">https://quarkpixel.github.io/p/250523-never-regarded-rust-as-safety</guid>
            <pubDate>Fri, 23 May 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[安全只是它的 Side Effects]]></description>
            <content:encoded><![CDATA[<p>每每在社交平台上看到有关 Rust 的内容，「内存安全」和「类型安全」总是如影随形，仿佛这是 Rust 的全部定义。Rust 似乎被贴上了一个光鲜的标签：安全语言。它的官网宣称「丰富的类型系统和所有权模型保证内存安全和线程安全」，社区也乐此不疲地传颂它的可靠性。然而，我从未将 Rust 视为一门「安全」的语言。安全，只是 Rust 独特设计带来的副作用，而非它的核心目标。Rust 的真正魅力，远不止于此。</p>
<p>在这篇文章中，我将从 Rust 的设计哲学出发，剖析安全特性如何作为副作用自然浮现；探讨为何「安全」标签被官方和社区共同放大；并揭示 Rust 在性能、表达力和灵活性上的多面价值。我希望你能放下对「安全」的刻板印象，重新审视这门语言。</p>
<h2>安全从何而来？</h2>
<p>Rust 诞生于 Mozilla，旨在解决 C++ 在系统编程中的痛点：手动内存管理复杂、并发问题难以调试、错误排查耗时。它的核心设计——所有权模型、借用检查器和生命周期——并非为了追求「安全」，而是为了让开发者能够编写可靠、高效的系统级代码。这些机制的细节可以在 <a href="https://doc.rust-lang.org/book/">Rust 官方书籍</a> 中找到，但其核心思想很简单：通过编译时规则，确保内存和并发行为的正确性。</p>
<p>所有权模型规定，每个值有且仅有一个所有者，值在作用域结束时自动销毁。这消除了 C++ 中手动释放内存的负担，同时避免了悬垂指针和双重释放。借用检查器进一步通过引用规则（不可变借用与可变借用互斥）约束内存访问，防止数据竞争。生命周期则确保引用的有效性，避免引用失效。这些机制共同构成了 Rust 的编译时保障体系，杜绝了空指针、缓冲区溢出等常见错误。</p>
<p>但这些规则的初衷是什么？不是为了让开发者炫耀「我的代码内存安全」，而是为了解放我们，让我们专注于程序逻辑而非调试内存泄漏或线程死锁。安全，只是这些设计的副作用就。像健康饮食可能带来体重控制，Rust 的设计目标是可靠性和性能，安全是实现这些目标的自然结果。官方虽然强调「内存安全和线程安全」，但更突出「赋予每个人构建可靠且高效软件」的愿景。<strong>安全是手段，而非目的。</strong></p>
<h2>Unsafe：语法层面的注释</h2>
<p>如果 Rust 的安全特性是其设计的全部，为何它还提供了 <code>unsafe</code> 关键字？其实这个问题很好回答。毕竟作为一个系统级的编程语言，对底层的可操控性和 Python 一样、或者语法像 C++ 一样灵活好像都不那么合适。因此引入了这样一个「乍看奇怪，实则合理」的产物。</p>
<p>我对 <code>unsafe</code> 的理解是，它是一种降低开发者心智负担的工具。在非 <code>unsafe</code> 代码中，Rust 的所有权模型和借用检查器充当守门人，自动防止内存泄漏、数据竞争或空指针错误。开发者无需时刻担心变量生命周期或指针合法性，编译器会在错误发生前报错。这种「默认安全」让开发者专注于逻辑而非内存管理。然而，当需要与硬件交互或优化性能时，unsafe 就像一个路标，提醒开发者：「这里要小心。」它要求明确声明责任，划定安全与非安全的边界。</p>
<p>与 C++ 不同，C++ 要求开发者时刻保持警惕，而 Rust 的 unsafe 将高风险操作隔离到特定代码块，让开发者在大多数时候可以「偷懒」，仅在必要时全神贯注。这种设计平衡了安全与灵活性，体现了 Rust 的实用主义：通过编译时约束最大化可靠性，同时保留系统编程的控制力。unsafe 不是对安全的妥协，而是对开发者的信任，提醒他们在自由与责任间选择。安全，仍是 Rust 优化心智负担的副作用，而非绝对目标。</p>
<h2>再谈为何「安全」被放大</h2>
<p>「安全」成为 Rust 的代名词，源于官方的宣传以及社交媒体上越发趋于给一个事物打“标签”。现在的编程语言市场已经趋于饱和，对于新兴语言来说，极力需要一个“卖点”来推销自己。对于官方来说，「安全」就是那个卖点。而对于社交媒体来说，没有一个词可以比「安全」这样一个简洁有力的词来概括一门语言了。因此社交媒体上的这种做法，是极其不负责任的。</p>
<p>但“安全”标签带来了认知偏差，让 Rust 被简化为“防御性”语言，掩盖其性能和表达力的优势。借用检查器的严格性让新手望而却步，凸显安全并非免费。作为程序员，我们应跳出“安全”这个人云亦云的概念，更加客观、更加全面的去了解一件事物。</p>
<h2>安全之外</h2>
<p>如果安全只是副作用，Rust 的真正价值是什么？答案在于它的多面性：性能、表达力和灵活性的完美平衡。</p>
<p>首先，Rust 的性能接近 C++，得益于其零成本抽象（Zero-Cost Abstractions）。它没有运行时或垃圾回收器，编译器通过优化（如内联、循环展开）确保代码高效运行。这使得 Rust 在高性能场景（如 <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm">WebAssembly</a>、嵌入式系统）中大放异彩。</p>
<p>其次，Rust 的类型系统和宏系统提供了强大的表达力。枚举和模式匹配让复杂逻辑更加简洁优雅；<a href="https://doc.rust-lang.org/book/ch20-05-macros.html">声明式宏</a>（<code>macro_rules!</code>）和过程宏支持元编程，极大地减少样板代码。这些特性让 Rust 代码不仅可靠，还充满美感，吸引了追求代码艺术的开发者。</p>
<p>最后，Rust 的灵活性使其超越了传统系统编程语言的范畴。它支持多种编程范式（函数式、面向对象），适用于从区块链到 AI 的广泛领域。例如，Discord 使用 Rust 优化后端，AWS 的 Firecracker 虚拟化技术也依赖 Rust 的高性能和可靠性。这些案例虽非重点，但足以证明 Rust 的通用性。</p>
<p>安全只是 Rust 的敲门砖。它的真正魅力在于，它让开发者在性能、可靠性和表达力之间找到平衡。你可以编写接近硬件的低级代码，也可以构建抽象层次高、逻辑清晰的高级系统，而不必被内存管理或并发问题拖累。Rust 不是“安全的 C++”，而是一门重新定义系统编程的语言。</p>
<h2>重新定义 Rust 的价值</h2>
<p>Rust 的魅力远不止「安全」二字。它以所有权模型和编译时检查为开发者卸下内存管理的重担，却从不以安全为唯一目标。性能、表达力与灵活性的融合，让 Rust 成为系统编程的新标杆。放下「安全语言」的刻板标签，我们应重新审视 Rust 的初心：赋予开发者自由与掌控力，构建可靠而高效的未来。无论是优化性能的极致追求，还是优雅代码的艺术表达，Rust 都以其独特的设计，邀请我们探索系统编程的无限可能。</p>
]]></content:encoded>
            <author>xuancongmeng@gmail.com (Xuancong Meng)</author>
            <category>[ 'Rust' ]</category>
        </item>
    </channel>
</rss>